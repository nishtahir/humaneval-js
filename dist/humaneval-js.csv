,task_id,prompt,canonical_solution,test,entry_point
0,0,"/**
 * Check if in given array of numbers, any two numbers are closer to each other than threshold.
 *
 * @param {number[]} numbers - List of numbers.
 * @param {number} threshold - Threshold for closeness.
 * @returns {boolean} True if any two numbers are closer than threshold.
 * @example
 * hasCloseElements([1.0, 2.0, 3.0], 0.5); // false
 * @example
 * hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3); // true
 */
function hasCloseElements(numbers, threshold) {","for (let idx = 0; idx < numbers.length; idx++) {
        const elem = numbers[idx];
        for (let idx2 = 0; idx2 < numbers.length; idx2++) {
            if (idx !== idx2) {
                const elem2 = numbers[idx2];
                const distance = Math.abs(elem - elem2);
                if (distance < threshold) {
                    return true;
                }
            }
        }
    }
    return false;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    console.assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true);
    console.assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false);
    console.assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true);
    console.assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false);
    console.assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true);
    console.assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true);
    console.assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false);
}",hasCloseElements
1,1,"/**
 * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
 * separate those groups into separate strings and return the list of those.
 * Separate groups are balanced (each open brace is properly closed) and not nested within each other.
 * Ignore any spaces in the input string.
 * @example
 * // returns ['()', '(())', '(()())']
 * separateParenGroups('( ) (( )) (( )( ))');
 * @param {string} parenString
 * @returns {string[]}
*/
function separateParenGroups(parenString) {","const result = [];
    let currentString = [];
    let currentDepth = 0;
    
    for (const c of parenString) {
        if (c === '(') {
            currentDepth++;
            currentString.push(c);
        } else if (c === ')') {
            currentDepth--;
            currentString.push(c);
            
            if (currentDepth === 0) {
                result.push(currentString.join(''));
                currentString.length = 0;
            }
        }
    }
    
    return result;
}","const assert = require('assert');

const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    assert.deepStrictEqual(candidate('(()()) ((())) () ((())()())'), [
        '(()())', '((()))', '()', '((())()())'
    ]);
    assert.deepStrictEqual(candidate('() (()) ((())) (((())))'), [
        '()', '(())', '((()))', '(((())))'
    ]);
    assert.deepStrictEqual(candidate('(()(())((())))'), [
        '(()(())((())))'
    ]);
    assert.deepStrictEqual(candidate('( ) (( )) (( )( ))'), ['()', '(())', '(()())']);
}",separateParenGroups
76,2,"/**
 * Given a positive floating point number, it can be decomposed into
 * an integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 *
 * Return the decimal part of the number.
 * @example
 * // returns 0.5
 * truncateNumber(3.5);
 * @param {number} number - The number to truncate.
 * @returns {number} The decimal part of the number.
 */
function truncateNumber(number) {","return number % 1.0;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    if (candidate(3.5) !== 0.5) {
        throw new Error(`Expected 0.5, got ${candidate(3.5)}`);
    }
    if (Math.abs(candidate(1.33) - 0.33) >= 1e-6) {
        throw new Error(`Expected approx 0.33, got ${candidate(1.33)}`);
    }
    if (Math.abs(candidate(123.456) - 0.456) >= 1e-6) {
        throw new Error(`Expected approx 0.456, got ${candidate(123.456)}`);
    }
}",truncateNumber
87,3,"/**
 * You're given a list of deposit and withdrawal operations on a bank account that starts with
 * zero balance. Your task is to detect if at any point the balance of the account falls below zero,
 * and at that point the function should return true. Otherwise it should return false.
 * @param {number[]} operations
 * @returns {boolean}
 * @example belowZero([1, 2, 3]); // false
 * @example belowZero([1, 2, -4, 5]); // true
 */
function belowZero(operations) {","let balance = 0;

    for (const op of operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }

    return false;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    console.assert(candidate([]) === false);
    console.assert(candidate([1, 2, -3, 1, 2, -3]) === false);
    console.assert(candidate([1, 2, -4, 5, 6]) === true);
    console.assert(candidate([1, -1, 2, -2, 5, -5, 4, -4]) === false);
    console.assert(candidate([1, -1, 2, -2, 5, -5, 4, -5]) === true);
    console.assert(candidate([1, -2, 2, -2, 5, -5, 4, -4]) === true);
}",belowZero
98,4,"/**
 * For a given array of input numbers, calculate Mean Absolute Deviation
 * around the mean of this dataset.
 * Mean Absolute Deviation is the average absolute difference between each
 * element and a centerpoint (mean in this case):
 * MAD = average | x - x_mean |
 *
 * @param {number[]} numbers - Array of numbers
 * @returns {number} Mean Absolute Deviation
 *
 * @example
 * meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]); // 1.0
 */
function meanAbsoluteDeviation(numbers) {","const mean = numbers.reduce((sum, x) => sum + x, 0) / numbers.length;
    const totalDev = numbers.reduce((sum, x) => sum + Math.abs(x - mean), 0);
    return totalDev / numbers.length;
}","const assert = require('assert');

const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    assert(Math.abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6);
    assert(Math.abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6);
    assert(Math.abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6);
}",meanAbsoluteDeviation
109,5,"/**
 * Insert a number 'delimeter' between every two consecutive elements of input array `numbers`.
 * @param {number[]} numbers
 * @param {number} delimeter
 * @returns {number[]}
 * @example
 * intersperse([], 4); // []
 * @example
 * intersperse([1, 2, 3], 4); // [1, 4, 2, 4, 3]
 */
function intersperse(numbers, delimeter) {","if (!numbers || numbers.length === 0) {
        return [];
    }
    const result = [];
    for (let i = 0; i < numbers.length - 1; i++) {
        result.push(numbers[i]);
        result.push(delimeter);
    }
    result.push(numbers[numbers.length - 1]);
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([], 7), []);
    assert.deepStrictEqual(candidate([5, 6, 3, 2], 8), [5, 8, 6, 8, 3, 8, 2]);
    assert.deepStrictEqual(candidate([2, 2, 2], 2), [2, 2, 2, 2, 2]);
}",intersperse
120,6,"/**
 * Input to this function is a string representing multiple groups of nested parentheses separated by spaces.
 * For each group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 *
 * @param {string} parenString
 * @returns {number[]}
 *
 * @example
 * parseNestedParens('(()()) ((())) () ((())()())'); // [2, 3, 1, 3]
 */
function parseNestedParens(parenString) {","function parseParenGroup(s) {
        let depth = 0;
        let maxDepth = 0;
        for (const c of s) {
            if (c === '(') {
                depth++;
                if (depth > maxDepth) maxDepth = depth;
            } else {
                depth--;
            }
        }
        return maxDepth;
    }
    return parenString.split(' ').filter(x => x).map(parseParenGroup);
}","const assert = require('assert');
const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    assert.deepStrictEqual(candidate('(()()) ((())) () ((())()())'), [2, 3, 1, 3]);
    assert.deepStrictEqual(candidate('() (()) ((())) (((())))'), [1, 2, 3, 4]);
    assert.deepStrictEqual(candidate('(()(())((())))'), [4]);
}",parseNestedParens
131,7,"/**
 * Filter an input array of strings only for ones that contain the given substring.
 *
 * Examples:
 *   filterBySubstring([], 'a'); // []
 *   filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a'); // ['abc', 'bacd', 'array']
 * @param {string[]} strings - Array of input strings.
 * @param {string} substring - Substring to filter by.
 * @returns {string[]} Filtered array of strings containing the substring.
 */
function filterBySubstring(strings, substring) {","return strings.filter(x => x.includes(substring));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([], 'john'), []);
    assert.deepStrictEqual(candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx'), ['xxx', 'xxxAAA', 'xxx']);
    assert.deepStrictEqual(candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx'), ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']);
    assert.deepStrictEqual(candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run'), ['grunt', 'prune']);
}",filterBySubstring
142,8,"/**
 * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * @param {number[]} numbers
 * @returns {[number, number]}
 * @example
 * // returns [0, 1]
 * sumProduct([]);
 * @example
 * // returns [10, 24]
 * sumProduct([1, 2, 3, 4]);
 */
function sumProduct(numbers) {","let sumValue = 0;
    let prodValue = 1;
    for (const n of numbers) {
        sumValue += n;
        prodValue *= n;
    }
    return [sumValue, prodValue];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([]), [0, 1]);
    assert.deepStrictEqual(candidate([1, 1, 1]), [3, 1]);
    assert.deepStrictEqual(candidate([100, 0]), [100, 0]);
    assert.deepStrictEqual(candidate([3, 5, 7]), [3 + 5 + 7, 3 * 5 * 7]);
    assert.deepStrictEqual(candidate([10]), [10, 10]);
}",sumProduct
153,9,"/**
 * From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * @param {number[]} numbers
 * @returns {number[]}
 * @example
 * // returns [1, 2, 3, 3, 3, 4, 4]
 * rolling_max([1, 2, 3, 2, 3, 4, 2]);
*/
function rolling_max(numbers) {","let running_max = null;
    const result = [];
    
    for (const n of numbers) {
        if (running_max === null) {
            running_max = n;
        } else {
            running_max = Math.max(running_max, n);
        }
        result.push(running_max);
    }
    
    return result;
}","const assert = require('assert');

const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([1, 2, 3, 4]), [1, 2, 3, 4]);
    assert.deepStrictEqual(candidate([4, 3, 2, 1]), [4, 4, 4, 4]);
    assert.deepStrictEqual(candidate([3, 2, 3, 100, 3]), [3, 3, 3, 100, 100]);
}",rolling_max
2,10,"/**
 * Test if given string is a palindrome
 * @param {string} string
 * @returns {boolean}
 */
function isPalindrome(string) {
    return string === string.split('').reverse().join('');
}

/**
 * Find the shortest palindrome that begins with a supplied string.
 * Algorithm idea is simple:
 * - Find the longest postfix of supplied string that is a palindrome.
 * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
 * @param {string} string
 * @returns {string}
 * @example
 * makePalindrome('') // ''
 * makePalindrome('cat') // 'catac'
 * makePalindrome('cata') // 'catac'
 */
function makePalindrome(string) {","if (string === '') {
        return '';
    }

    let beginningOfSuffix = 0;

    while (!isPalindrome(string.slice(beginningOfSuffix))) {
        beginningOfSuffix += 1;
    }

    const prefix = string.slice(0, beginningOfSuffix);
    const reversedPrefix = prefix.split('').reverse().join('');
    return string + reversedPrefix;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), '');
    assert.strictEqual(candidate('x'), 'x');
    assert.strictEqual(candidate('xyz'), 'xyzyx');
    assert.strictEqual(candidate('xyx'), 'xyx');
    assert.strictEqual(candidate('jerry'), 'jerryrrej');
}",makePalindrome
13,11,"/**
 * Input are two strings a and b consisting only of '1's and '0's.
 * Perform binary XOR on these inputs and return result also as a string.
 *
 * @example
 * stringXor('010', '110'); // '100'
 *
 * @param {string} a
 * @param {string} b
 * @returns {string}
 */
function stringXor(a, b) {","function xor(i, j) {
        return i === j ? '0' : '1';
    }
    let result = '';
    const length = Math.min(a.length, b.length);
    for (let idx = 0; idx < length; idx++) {
        result += xor(a[idx], b[idx]);
    }
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.equal(candidate('111000', '101010'), '010010')
    assert.equal(candidate('1', '1'), '0')
    assert.equal(candidate('0101', '0000'), '0101')
}",stringXor
24,12,"/**
 * Out of list of strings, return the longest one. Return the first one in case of multiple
 * strings of the same length. Return null in case the input list is empty.
 * @param {string[]} strings
 * @returns {string|null}
 * @example
 * longest([]) // null
 * longest(['a', 'b', 'c']) // 'a'
 * longest(['a', 'bb', 'ccc']) // 'ccc'
 */
function longest(strings) {","if (!strings || strings.length === 0) {
        return null;
    }
    const maxlen = Math.max(...strings.map(s => s.length));
    for (const s of strings) {
        if (s.length === maxlen) {
            return s;
        }
    }
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.equal(candidate([]), null)
    assert.equal(candidate(['x', 'y', 'z']), 'x')
    assert.equal(candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']), 'zzzz')
}",longest
35,13,"/**
 * Return a greatest common divisor of two integers a and b
*
* @param {number} a - First integer.
* @param {number} b - Second integer.
* @returns {number} Greatest common divisor.
*
* @example
* greatestCommonDivisor(3, 5); // 1
* greatestCommonDivisor(25, 15); // 5
*/
function greatestCommonDivisor(a, b) {","while (b) {
        [a, b] = [b, a % b];
    }
    return a;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(3, 7), 1);
    assert.strictEqual(candidate(10, 15), 5);
    assert.strictEqual(candidate(49, 14), 7);
    assert.strictEqual(candidate(144, 60), 12);
}",greatestCommonDivisor
46,14,"/**
 * Return list of all prefixes from shortest to longest of the input string
 * @param {string} str
 * @returns {string[]}
 * @example
 * allPrefixes('abc'); // ['a', 'ab', 'abc']
 */
function allPrefixes(str) {","const result = [];
    for (let i = 0; i < str.length; i++) {
        result.push(str.slice(0, i + 1));
    }
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(''), []);
    assert.deepStrictEqual(candidate('asdfgh'), ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']);
    assert.deepStrictEqual(candidate('WWW'), ['W', 'WW', 'WWW']);
}",allPrefixes
57,15,"/**
 * Return a string containing space-delimited numbers starting from 0 up to n inclusive.
 *
 * @param {number} n
 * @returns {string}
 *
 * @example
 * string_sequence(0); // '0'
 * string_sequence(5); // '0 1 2 3 4 5'
 */
function string_sequence(n) {","return Array.from({ length: n + 1 }, (_, x) => x).join(' ');
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(0), '0');
    assert.strictEqual(candidate(3), '0 1 2 3');
    assert.strictEqual(candidate(10), '0 1 2 3 4 5 6 7 8 9 10');
}",string_sequence
68,16,"/**
 * Given a string, find out how many distinct characters (regardless of case) it consists of
 * @param {string} str
 * @returns {number}
 * @example
 * countDistinctCharacters('xyzXYZ'); // 3
 * countDistinctCharacters('Jerry');  // 4
 */

function countDistinctCharacters(str) {","return new Set(str.toLowerCase()).size;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), 0);
    assert.strictEqual(candidate('abcde'), 5);
    assert.strictEqual(candidate('abcde' + 'cade' + 'CADE'), 5);
    assert.strictEqual(candidate('aaaaAAAAaaaa'), 1);
    assert.strictEqual(candidate('Jerry jERRY JeRRRY'), 5);
}",countDistinctCharacters
73,17,"/**
 * Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each note last.
 *
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quarter note, lasts one beat
 *
 * @param {string} musicString
 * @returns {number[]}
 * @example
 * parseMusic('o o| .| o| o| .| .| .| .| o o')
 * // returns [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
 */
function parseMusic(musicString) {","const noteMap = { 'o': 4, 'o|': 2, '.|': 1 };
    return musicString.split(' ').filter(x => x).map(x => noteMap[x]);
}","const METADATA = { author: 'jt', dataset: 'test' };
const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(''), []);
    assert.deepStrictEqual(candidate('o o o o'), [4, 4, 4, 4]);
    assert.deepStrictEqual(candidate('.| .| .| .|'), [1, 1, 1, 1]);
    assert.deepStrictEqual(candidate('o| o| .| .| o o o o'), [2, 2, 1, 1, 4, 4, 4, 4]);
    assert.deepStrictEqual(candidate('o| .| o| .| o o| o o|'), [2, 1, 2, 1, 4, 2, 4, 2]);
}",parseMusic
74,18,"/**
 * Find how many times a given substring can be found in the original string. Count overlapping cases.
 * @param {string} string
 * @param {string} substring
 * @returns {number}
 *
 * Examples:
 *   howManyTimes('', 'a') // 0
 *   howManyTimes('aaa', 'a') // 3
 *   howManyTimes('aaaa', 'aa') // 3
 */
function howManyTimes(string, substring) {","let times = 0;
    for (let i = 0; i <= string.length - substring.length; i++) {
        if (string.slice(i, i + substring.length) === substring) {
            times++;
        }
    }
    return times;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');
function check(candidate) {
    assert(candidate('', 'x') === 0);
    assert(candidate('xyxyxyx', 'x') === 4);
    assert(candidate('cacacacac', 'cac') === 4);
    assert(candidate('john doe', 'john') === 1);
}",howManyTimes
75,19,"/**
 * Input is a space-delimited string of numerals from 'zero' to 'nine'.
 * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',
 * 'six', 'seven', 'eight' and 'nine'.
 * Return the string with numbers sorted from smallest to largest.
 * @example
 * // returns 'one three five'
 * sortNumbers('three one five');
 * @param {string} numbers
 * @returns {string}
 */
function sortNumbers(numbers) {","const valueMap = {
        zero: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6,
        seven: 7,
        eight: 8,
        nine: 9
    };
    return numbers
        .split(' ')
        .filter(x => x)
        .sort((a, b) => valueMap[a] - valueMap[b])
        .join(' ');
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), '');
    assert.strictEqual(candidate('three'), 'three');
    assert.strictEqual(candidate('three five nine'), 'three five nine');
    assert.strictEqual(candidate('five zero four seven nine eight'), 'zero four five seven eight nine');
    assert.strictEqual(candidate('six five four three two one zero'), 'zero one two three four five six');
}",sortNumbers
77,20,"/**
 * From a supplied array of numbers (length at least two) select and return two that are the closest to each
 * other and return them in order (smaller number, larger number).
 * @param {number[]} numbers
 * @returns {[number, number]}
*/
function findClosestElements(numbers) {","let closestPair = null;
    let distance = null;
    for (let i = 0; i < numbers.length; i++) {
        for (let j = 0; j < numbers.length; j++) {
            if (i !== j) {
                const a = numbers[i];
                const b = numbers[j];
                const diff = Math.abs(a - b);
                if (distance === null || diff < distance) {
                    distance = diff;
                    closestPair = [Math.min(a, b), Math.max(a, b)];
                }
            }
        }
    }
    return closestPair;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), [3.9, 4.0]);
    assert.deepStrictEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]), [5.0, 5.9]);
    assert.deepStrictEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), [2.0, 2.2]);
    assert.deepStrictEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), [2.0, 2.0]);
    assert.deepStrictEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]), [2.2, 3.1]);
}",findClosestElements
78,21,"/**
 * Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * @param {number[]} numbers
 * @returns {number[]}
 * @example
 * // returns [0.0, 0.25, 0.5, 0.75, 1.0]
 * rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0]);
 */
function rescaleToUnit(numbers) {","const minNumber = Math.min(...numbers);
    const maxNumber = Math.max(...numbers);
    return numbers.map(x => (x - minNumber) / (maxNumber - minNumber));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([2.0, 49.9]), [0.0, 1.0]);
    assert.deepStrictEqual(candidate([100.0, 49.9]), [1.0, 0.0]);
    assert.deepStrictEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]), [0.0, 0.25, 0.5, 0.75, 1.0]);
    assert.deepStrictEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]), [0.25, 0.0, 1.0, 0.5, 0.75]);
    assert.deepStrictEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]), [0.25, 0.0, 1.0, 0.5, 0.75]);
}",rescaleToUnit
79,22,"/**
 * Filter given array of any JS values only for integers.
 *
 * @param {Array<any>} values - The array of values to filter.
 * @returns {Array<number>} An array containing only the integer values.
 *
 * @example
 * filter_integers(['a', 3.14, 5]); // returns [5]
 * @example
 * filter_integers([1, 2, 3, 'abc', {}, []]); // returns [1, 2, 3]
*/
function filter_integers(values) {","return values.filter(x => Number.isInteger(x));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([4, {}, [], 23.2, 9, 'adasd']), [4, 9]);
    assert.deepStrictEqual(candidate([3, 'c', 3, 3, 'a', 'b']), [3, 3, 3]);
}",filter_integers
80,23,"/**
 * Return length of given string
 * @param {string} string
 * @returns {number}
 * @example
 * strlen('');
 * // => 0
 * strlen('abc');
 * // => 3
 */
function strlen(string) {","return string.length;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), 0);
    assert.strictEqual(candidate('x'), 1);
    assert.strictEqual(candidate('asdasnakj'), 9);
}",strlen
81,24,"/**
 * For a given number n, find the largest number that divides n evenly, smaller than n
 * @param {number} n
 * @returns {number}
 * @example
 * largestDivisor(15); // 5
 */
function largestDivisor(n) {","for (let i = n - 1; i >= 1; i--) {
    if (n % i === 0) {
      return i;
    }
  }
}","const METADATA = {
  author: 'jt',
  dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  assert.strictEqual(candidate(3), 1);
  assert.strictEqual(candidate(7), 1);
  assert.strictEqual(candidate(10), 5);
  assert.strictEqual(candidate(100), 50);
  assert.strictEqual(candidate(49), 7);
}",largestDivisor
82,25,"/**
 * Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.
 * Input number should be equal to the product of all factors.
 * @example
 * factorize(8) // [2, 2, 2]
 * factorize(25) // [5, 5]
 * factorize(70) // [2, 5, 7]
 * @param {number} n
 * @returns {number[]}
 */
function factorize(n) {","const fact = [];
    let i = 2;
    while (i <= Math.sqrt(n) + 1) {
        if (n % i === 0) {
            fact.push(i);
            n = n / i;
        } else {
            i += 1;
        }
    }
    if (n > 1) {
        fact.push(n);
    }
    return fact;
}","const assert = require('assert');

const METADATA = {
    author: 'jt',
    dataset: 'test'
};

function check(candidate) {
    assert.deepStrictEqual(candidate(2), [2]);
    assert.deepStrictEqual(candidate(4), [2, 2]);
    assert.deepStrictEqual(candidate(8), [2, 2, 2]);
    assert.deepStrictEqual(candidate(3 * 19), [3, 19]);
    assert.deepStrictEqual(candidate(3 * 19 * 3 * 19), [3, 3, 19, 19]);
    assert.deepStrictEqual(candidate(3 * 19 * 3 * 19 * 3 * 19), [3, 3, 3, 19, 19, 19]);
    assert.deepStrictEqual(candidate(3 * 19 * 19 * 19), [3, 19, 19, 19]);
    assert.deepStrictEqual(candidate(3 * 2 * 3), [2, 3, 3]);
}",factorize
83,26,"/**
 * From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * @param {number[]} numbers
 * @returns {number[]}
 * @example
 * removeDuplicates([1, 2, 3, 2, 4]); // [1, 3, 4]
*/
function removeDuplicates(numbers) {","const count = new Map();
    for (const n of numbers) {
        count.set(n, (count.get(n) || 0) + 1);
    }
    return numbers.filter(n => count.get(n) <= 1);
}","const METADATA = { author: 'jt', dataset: 'test' };

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([1, 2, 3, 4]), [1, 2, 3, 4]);
    assert.deepStrictEqual(candidate([1, 2, 3, 2, 4, 3, 5]), [1, 4, 5]);
}",removeDuplicates
84,27,"/**
 * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
 * @example
 *   flipCase('Hello'); // 'hELLO'
 * @param {string} string
 * @returns {string}
 */
function flipCase(string) {","return string
        .split('')
        .map(c => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase())
        .join('');
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), '');
    assert.strictEqual(candidate('Hello!'), 'hELLO!');
    assert.strictEqual(
        candidate('These violent delights have violent ends'),
        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
    );
}",flipCase
85,28,"/**
 * Concatenate list of strings into a single string.
 *
 * @param {string[]} strings - Array of strings to concatenate.
 * @returns {string} Concatenated string.
 * @example
 * // returns ''
 * concatenate([]);
 * @example
 * // returns 'abc'
 * concatenate(['a', 'b', 'c']);
 */
function concatenate(strings) {","return strings.join('');
}","const METADATA = { author: 'jt', dataset: 'test' };

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([]), '');
    assert.strictEqual(candidate(['x', 'y', 'z']), 'xyz');
    assert.strictEqual(candidate(['x', 'y', 'z', 'w', 'k']), 'xyzwk');
}",concatenate
86,29,"/**
 * Filter an input list of strings only for ones that start with a given prefix.
 * @param {string[]} strings - input list of strings
 * @param {string} prefix - the prefix to filter by
 * @returns {string[]} filtered list of strings starting with prefix
 * @example
 * filterByPrefix([], 'a'); // []
 * filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a'); // ['abc', 'array']
 */
function filterByPrefix(strings, prefix) {","return strings.filter(x => x.startsWith(prefix));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([], 'john'), [])
    assert.deepStrictEqual(candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx'), ['xxx', 'xxxAAA', 'xxx'])
}",filterByPrefix
88,30,"/**
 * Return only positive numbers in the list.
 * @param {number[]} l - array of numbers
 * @returns {number[]} filtered array containing only positive numbers
*
* @example
* getPositive([-1, 2, -4, 5, 6]); // [2, 5, 6]
* @example
* getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]); // [5, 3, 2, 3, 9, 123, 1]
*/
function getPositive(l) {","return l.filter(e => e > 0);
}","const METADATA = {};

const assert = require('assert');

function check(candidate) {
  assert.deepStrictEqual(candidate([-1, -2, 4, 5, 6]), [4, 5, 6]);
  assert.deepStrictEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), [5, 3, 2, 3, 3, 9, 123, 1]);
  assert.deepStrictEqual(candidate([-1, -2]), []);
  assert.deepStrictEqual(candidate([]), []);
}",getPositive
89,31,"/**
 * Return true if a given number is prime, and false otherwise.
 * @param {number} n - Number to check for primality.
 * @returns {boolean}
 * @example
 * isPrime(6); // false
 * isPrime(101); // true
 * isPrime(11); // true
 * isPrime(13441); // true
 * isPrime(61); // true
 * isPrime(4); // false
 * isPrime(1); // false
*/
function isPrime(n) {","if (n < 2) {
        return false;
    }
    for (let k = 2; k < n - 1; k++) {
        if (n % k === 0) {
            return false;
        }
    }
    return true;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(6), false);
    assert.strictEqual(candidate(101), true);
    assert.strictEqual(candidate(11), true);
    assert.strictEqual(candidate(13441), true);
    assert.strictEqual(candidate(61), true);
    assert.strictEqual(candidate(4), false);
    assert.strictEqual(candidate(1), false);
    assert.strictEqual(candidate(5), true);
    assert.strictEqual(candidate(11), true);
    assert.strictEqual(candidate(17), true);
    assert.strictEqual(candidate(5 * 17), false);
    assert.strictEqual(candidate(11 * 7), false);
    assert.strictEqual(candidate(13441 * 19), false);
}",isPrime
90,32,"/**
 * Evaluates polynomial with coefficients xs at point x.
 * returns xs[0] + xs[1] * x + xs[2] * x^2 + ... xs[n] * x^n
 * @param {number[]} xs
 * @param {number} x
 * @returns {number}
 */
function poly(xs, x) {
    return xs.reduce((sum, coeff, i) => sum + coeff * Math.pow(x, i), 0);
}

/**
 * xs are coefficients of a polynomial.
 * findZero finds x such that poly(xs, x) = 0.
 * findZero returns only one zero point, even if there are many.
 * Moreover, findZero only takes list xs having even number of coefficients
 * and largest non zero coefficient as it guarantees
 * a solution.
 * @param {number[]} xs
 * @returns {number}
*/
function findZero(xs) {","let begin = -1.0;
    let end = 1.0;
    while (poly(xs, begin) * poly(xs, end) > 0) {
        begin *= 2.0;
        end *= 2.0;
    }
    while (end - begin > 1e-10) {
        const center = (begin + end) / 2.0;
        if (poly(xs, center) * poly(xs, begin) > 0) {
            begin = center;
        } else {
            end = center;
        }
    }
    return begin;
}","const assert = require('assert');

function check(candidate) {
    for (let t = 0; t < 100; t++) {
        const ncoeff = 2 * Math.floor(Math.random() * 4 + 1);
        const coeffs = [];
        for (let i = 0; i < ncoeff; i++) {
            let coeff = Math.floor(Math.random() * 21) - 10;
            if (coeff === 0) coeff = 1;
            coeffs.push(coeff);
        }
        const sol = candidate(coeffs.slice());
        assert(Math.abs(poly(coeffs, sol)) < 1e-4);
    }
}",findZero
91,33,"/**
 * This function takes an array l and returns a new array l' such that
 * l' is identical to l at indices not divisible by three, while its values
 * at indices divisible by three are equal to the values of the corresponding
 * indices of l, but sorted.
 * @param {number[]} l
 * @returns {number[]}
 * @example
 * sortThird([1, 2, 3]); // [1, 2, 3]
 * sortThird([5, 6, 3, 4, 8, 9, 2]); // [2, 6, 3, 4, 8, 9, 5]
*/
function sortThird(l) {","const result = l.slice();
  const elems = [];
  for (let i = 0; i < result.length; i += 3) {
    elems.push(result[i]);
  }
  elems.sort((a, b) => a - b);
  let idx = 0;
  for (let i = 0; i < result.length; i += 3) {
    result[i] = elems[idx++];
  }
  return result;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  assert.deepStrictEqual(candidate([1, 2, 3]), sortThird([1, 2, 3]));
  assert.deepStrictEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]));
  assert.deepStrictEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]));
  assert.deepStrictEqual(candidate([5, 6, 3, 4, 8, 9, 2]), [2, 6, 3, 4, 8, 9, 5]);
  assert.deepStrictEqual(candidate([5, 8, 3, 4, 6, 9, 2]), [2, 8, 3, 4, 6, 9, 5]);
  assert.deepStrictEqual(candidate([5, 6, 9, 4, 8, 3, 2]), [2, 6, 9, 4, 8, 3, 5]);
  assert.deepStrictEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]), [2, 6, 3, 4, 8, 9, 5, 1]);
}",sortThird
92,34,"/**
 * Return sorted unique elements in a list
 * @param {Array<number>} l - list of numbers
 * @returns {Array<number>} sorted unique elements
 * @example
 * unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);
 * // returns [0, 2, 3, 5, 9, 123]
*/
function unique(l) {","return Array.from(new Set(l)).sort((a, b) => a - b);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]), [0, 2, 3, 5, 9, 123]);
}",unique
93,35,"/**
 * Return maximum element in the list.
 * @param {number[]} l - The list of numbers.
 * @returns {number} The maximum element.
 * @example
 * // returns 3
 * maxElement([1, 2, 3]);
 * @example
 * // returns 123
 * maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]);
 */
function maxElement(l) {","let m = l[0];
    for (const e of l) {
        if (e > m) {
            m = e;
        }
    }
    return m;
}","const METADATA = {}
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([1, 2, 3]), 3);
    assert.strictEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}",maxElement
94,36,"/**
 * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 *
 * Examples:
 *   fizzBuzz(50) // 0
 *   fizzBuzz(78) // 2
 *   fizzBuzz(79) // 3
 *
 * @param {number} n
 * @returns {number}
 */
function fizzBuzz(n) {","const ns = [];
    for (let i = 0; i < n; i++) {
        if (i % 11 === 0 || i % 13 === 0) {
            ns.push(i);
        }
    }
    const s = ns.join('');
    let ans = 0;
    for (const c of s) {
        if (c === '7') {
            ans++;
        }
    }
    return ans;
}","const METADATA = {};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(50), 0);
    assert.strictEqual(candidate(78), 2);
    assert.strictEqual(candidate(79), 3);
    assert.strictEqual(candidate(100), 3);
    assert.strictEqual(candidate(200), 6);
    assert.strictEqual(candidate(4000), 192);
    assert.strictEqual(candidate(10000), 639);
    assert.strictEqual(candidate(100000), 8026);
}",fizzBuzz
95,37,"/**
 * This function takes an array l and returns a new array such that
 * elements at odd indices remain the same, while elements at even indices
 * are sorted among themselves.
 * @param {number[]} l
 * @returns {number[]}
 * @example
 * sort_even([1, 2, 3]); // [1, 2, 3]
 * sort_even([5, 6, 3, 4]); // [3, 6, 5, 4]
 */
function sort_even(l) {","const evens = [];
    const odds = [];
    for (let i = 0; i < l.length; i++) {
        if (i % 2 === 0) {
            evens.push(l[i]);
        } else {
            odds.push(l[i]);
        }
    }
    evens.sort((a, b) => a - b);
    const ans = [];
    const minLen = Math.min(evens.length, odds.length);
    for (let i = 0; i < minLen; i++) {
        ans.push(evens[i], odds[i]);
    }
    if (evens.length > odds.length) {
        ans.push(evens[evens.length - 1]);
    }
    return ans;
}","const METADATA = {}

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([1, 2, 3]), [1, 2, 3]);
    assert.deepStrictEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert.deepStrictEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}",sort_even
96,38,"/**
 * returns encoded string by cycling groups of three characters.
 * @param {string} s
 * @returns {string}
 */
function encodeCyclic(s) {
    // split string to groups. Each of length 3.
    const groups = [];
    for (let i = 0; i < Math.ceil(s.length / 3); i++) {
        groups.push(s.slice(3 * i, Math.min(3 * i + 3, s.length)));
    }
    // cycle elements in each group. Unless group has fewer elements than 3.
    const cycled = groups.map(group =>
        group.length === 3 ? group.slice(1) + group[0] : group
    );
    return cycled.join('');
}

/**
 * takes as input string encoded with encodeCyclic function. Returns decoded string.
 * @param {string} s
 * @returns {string}
 */
function decodeCyclic(s) {","return encodeCyclic(encodeCyclic(s));
}","const METADATA = {}

const assert = require('assert');
const letters = 'abcdefghijklmnopqrstuvwxyz';

function check(candidate) {
    for (let i = 0; i < 100; i++) {
        const len = Math.floor(Math.random() * 11) + 10; // random length between 10 and 20
        let str = '';
        for (let j = 0; j < len; j++) {
            str += letters[Math.floor(Math.random() * letters.length)];
        }
        const encoded = encodeCyclic(str);
        assert.strictEqual(candidate(encoded), str);
    }
}",decodeCyclic
97,39,"/**
 * primeFib returns the n-th number that is both a Fibonacci number and prime.
 * @param {number} n
 * @returns {number}
 * @example
 * primeFib(1) // 2
 * primeFib(2) // 3
 * primeFib(3) // 5
 * primeFib(4) // 13
 * primeFib(5) // 89
 */
function primeFib(n) {","function isPrime(p) {
        if (p < 2) return false;
        const limit = Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1);
        for (let k = 2; k < limit; k++) {
            if (p % k === 0) return false;
        }
        return true;
    }
    const f = [0, 1];
    while (true) {
        f.push(f[f.length - 1] + f[f.length - 2]);
        if (isPrime(f[f.length - 1])) {
            n--;
        }
        if (n === 0) {
            return f[f.length - 1];
        }
    }
}","const METADATA = {}

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(1), 2);
    assert.strictEqual(candidate(2), 3);
    assert.strictEqual(candidate(3), 5);
    assert.strictEqual(candidate(4), 13);
    assert.strictEqual(candidate(5), 89);
    assert.strictEqual(candidate(6), 233);
    assert.strictEqual(candidate(7), 1597);
    assert.strictEqual(candidate(8), 28657);
    assert.strictEqual(candidate(9), 514229);
    assert.strictEqual(candidate(10), 433494437);
}",primeFib
99,40,"/**
 * triplesSumToZero takes an array of integers as an input.
 * It returns true if there are three distinct elements in the array that
 * sum to zero, and false otherwise.
 *
 * Examples:
 *   triplesSumToZero([1, 3, 5, 0]); // false
 *   triplesSumToZero([1, 3, -2, 1]); // true
 *   triplesSumToZero([1, 2, 3, 7]); // false
 *   triplesSumToZero([2, 4, -5, 3, 9, 7]); // true
 *   triplesSumToZero([1]); // false
 */

function triplesSumToZero(l) {","for (let i = 0; i < l.length; i++) {
        for (let j = i + 1; j < l.length; j++) {
            for (let k = j + 1; k < l.length; k++) {
                if (l[i] + l[j] + l[k] === 0) {
                    return true;
                }
            }
        }
    }
    return false;
}","const METADATA = {};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([1, 3, 5, 0]), false);
    assert.strictEqual(candidate([1, 3, 5, -1]), false);
    assert.strictEqual(candidate([1, 3, -2, 1]), true);
    assert.strictEqual(candidate([1, 2, 3, 7]), false);
    assert.strictEqual(candidate([1, 2, 5, 7]), false);
    assert.strictEqual(candidate([2, 4, -5, 3, 9, 7]), true);
    assert.strictEqual(candidate([1]), false);
    assert.strictEqual(candidate([1, 3, 5, -100]), false);
    assert.strictEqual(candidate([100, 3, 5, -100]), false);
}",triplesSumToZero
100,41,"/**
 * Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right; simultaneously, a different set of n cars
 * are driving right to left. The two sets of cars start out being very far from
 * each other. All cars move at the same speed. Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 *
 * @param {number} n - number of cars in each set
 * @returns {number} number of collisions
 */
function carRaceCollision(n) {","return n * n;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(2), 4);
    assert.strictEqual(candidate(3), 9);
    assert.strictEqual(candidate(4), 16);
    assert.strictEqual(candidate(8), 64);
    assert.strictEqual(candidate(10), 100);
}",carRaceCollision
101,42,"/**
 * Return list with elements incremented by 1.
 * @example
 * incr_list([1, 2, 3]);
 * // returns [2, 3, 4]
 * @example
 * incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]);
 * // returns [6, 4, 6, 3, 4, 4, 10, 1, 124]
 * @param {number[]} l
 * @returns {number[]}
 */
function incrList(l) {","return l.map(e => e + 1);
}","const METADATA = {};
const assert = require(""assert"")

function check(candidate) {
    assert.deepStrictEqual(candidate([]), [])
    assert.deepStrictEqual(candidate([3, 2, 1]), [4, 3, 2])
    assert.deepStrictEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]), [6, 3, 6, 3, 4, 4, 10, 1, 124])
}",incrList
102,43,"/**
 * pairsSumToZero takes an array of integers as an input.
 * It returns true if there are two distinct elements in the array that
 * sum to zero, and false otherwise.
 *
 * @param {number[]} arr
 * @returns {boolean}
 *
 * @example
 * pairsSumToZero([1, 3, 5, 0]); // false
 * pairsSumToZero([1, 3, -2, 1]); // false
 * pairsSumToZero([1, 2, 3, 7]); // false
 * pairsSumToZero([2, 4, -5, 3, 5, 7]); // true
 * pairsSumToZero([1]); // false
 */
function pairsSumToZero(arr) {","for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === 0) {
                return true;
            }
        }
    }
    return false;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([1, 3, 5, 0]), false);
    assert.strictEqual(candidate([1, 3, -2, 1]), false);
    assert.strictEqual(candidate([1, 2, 3, 7]), false);
    assert.strictEqual(candidate([2, 4, -5, 3, 5, 7]), true);
    assert.strictEqual(candidate([1]), false);

    assert.strictEqual(candidate([-3, 9, -1, 3, 2, 30]), true);
    assert.strictEqual(candidate([-3, 9, -1, 3, 2, 31]), true);
    assert.strictEqual(candidate([-3, 9, -1, 4, 2, 30]), false);
    assert.strictEqual(candidate([-3, 9, -1, 4, 2, 31]), false);
}",pairsSumToZero
103,44,"/**
 * Change numerical base of input number x to base.
 * return string representation after the conversion.
 * base numbers are less than 10.
 * @param {number} x - the number to convert.
 * @param {number} base - the base to convert to (less than 10).
 * @returns {string} the string representation of x in the given base.
 * @example
 * changeBase(8, 3); // '22'
 * changeBase(8, 2); // '1000'
 * changeBase(7, 2); // '111'
 */
function changeBase(x, base) {","let ret = """";
    while (x > 0) {
        ret = String(x % base) + ret;
        x = Math.floor(x / base);
    }
    return ret;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(8, 3), ""22"");
    assert.strictEqual(candidate(9, 3), ""100"");
    assert.strictEqual(candidate(234, 2), ""11101010"");
    assert.strictEqual(candidate(16, 2), ""10000"");
    assert.strictEqual(candidate(8, 2), ""1000"");
    assert.strictEqual(candidate(7, 2), ""111"");
    for (let x = 2; x < 8; x++) {
        assert.strictEqual(candidate(x, x + 1), String(x));
    }
}",changeBase
104,45,"/**
 * Given length of a side and high return area for a triangle.
 * @param {number} a - length of a side
 * @param {number} h - high of the triangle
 * @returns {number} area of the triangle
 * @example
 * triangle_area(5, 3); // 7.5
 */
function triangle_area(a, h) {","return a * h / 2.0;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(5, 3), 7.5);
    assert.strictEqual(candidate(2, 2), 2.0);
    assert.strictEqual(candidate(10, 8), 40.0);
}",triangle_area
105,46,"/**
 * The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:
 * fib4(0) -> 0
 * fib4(1) -> 0
 * fib4(2) -> 2
 * fib4(3) -> 0
 * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
 * Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.
 *
 * Examples:
 *   fib4(5) -> 4
 *   fib4(6) -> 8
 *   fib4(7) -> 14
 */

/**
 * Computes the n-th element of the fib4 number sequence.
 * @param {number} n
 * @returns {number}
*/
function fib4(n) {","const results = [0, 0, 2, 0];
    if (n < 4) {
        return results[n];
    }
    for (let i = 4; i <= n; i++) {
        const sum = results[0] + results[1] + results[2] + results[3];
        results.push(sum);
        results.shift();
    }
    return results[3];
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(5), 4);
    assert.strictEqual(candidate(8), 28);
    assert.strictEqual(candidate(10), 104);
    assert.strictEqual(candidate(12), 386);
}",fib4
106,47,"/**
 * Return median of elements in the list l.
 *
 * @param {number[]} l - array of numbers
 * @returns {number} median of the array
 *
 * >>> median([3, 1, 2, 4, 5])
 * 3
 * >>> median([-10, 4, 6, 1000, 10, 20])
 * 15.0
 */
function median(l) {","const sorted = [...l].sort((a, b) => a - b);
    const n = sorted.length;
    if (n % 2 === 1) {
        return sorted[Math.floor(n / 2)];
    } else {
        return (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;
    }
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([3, 1, 2, 4, 5]), 3);
    assert.strictEqual(candidate([-10, 4, 6, 1000, 10, 20]), 8.0);
    assert.strictEqual(candidate([5]), 5);
    assert.strictEqual(candidate([6, 5]), 5.5);
    assert.strictEqual(candidate([8, 1, 3, 9, 9, 2, 7]), 7);
}",median
107,48,"/**
 * Checks if given string is a palindrome
 * @param {string} text
 * @returns {boolean}
 * @example
 * isPalindrome('');
 * // returns true
 * isPalindrome('aba');
 * // returns true
 * isPalindrome('aaaaa');
 * // returns true
 * isPalindrome('zbcd');
 * // returns false
 */
function isPalindrome(text) {","for (let i = 0; i < text.length; i++) {
        if (text[i] !== text[text.length - 1 - i]) {
            return false;
        }
    }
    return true;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(''), true);
    assert.strictEqual(candidate('aba'), true);
    assert.strictEqual(candidate('aaaaa'), true);
    assert.strictEqual(candidate('zbcd'), false);
    assert.strictEqual(candidate('xywyx'), true);
    assert.strictEqual(candidate('xywyz'), false);
    assert.strictEqual(candidate('xywzx'), false);
}",isPalindrome
108,49,"/**
 * Return 2^n modulo p (be aware of numerics).
 * @param {number} n
 * @param {number} p
 * @returns {number}
 */
function modp(n, p) {","let ret = 1;
    for (let i = 0; i < n; i++) {
        ret = (2 * ret) % p;
    }
    return ret;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(3, 5), 3);
    assert.strictEqual(candidate(1101, 101), 2);
    assert.strictEqual(candidate(0, 101), 1);
    assert.strictEqual(candidate(3, 11), 8);
    assert.strictEqual(candidate(100, 101), 1);
    assert.strictEqual(candidate(30, 5), 4);
    assert.strictEqual(candidate(31, 5), 3);
}",modp
110,50,"/**
 * returns encoded string by shifting every character by 5 in the alphabet.
 * @param {string} s
 * @returns {string}
 */
function encodeShift(s) {
    return s.split('').map(ch => {
        const code = ch.charCodeAt(0);
        const aCode = 'a'.charCodeAt(0);
        return String.fromCharCode(((code + 5 - aCode) % 26) + aCode);
    }).join('');
}

/**
 * takes as input string encoded with encodeShift function. Returns decoded string.
 * @param {string} s
 * @returns {string}
 */
function decodeShift(s) {","return s.split('').map(ch => {
        const code = ch.charCodeAt(0);
        const aCode = 'a'.charCodeAt(0);
        return String.fromCharCode(((code - 5 - aCode + 26) % 26) + aCode);
    }).join('');
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    const letters = 'abcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 100; i++) {
        const len = Math.floor(Math.random() * 11) + 10;
        let str = '';
        for (let j = 0; j < len; j++) {
            str += letters.charAt(Math.floor(Math.random() * letters.length));
        }
        const encodedStr = encodeShift(str);
        assert.strictEqual(candidate(encodedStr), str);
    }
}",decodeShift
111,51,"/**
 * remove_vowels is a function that takes string and returns string without vowels.
 *
 * Examples:
 * remove_vowels('') -> ''
 * remove_vowels(""abcdef\nghijklm"") -> 'bcdf\nghjklm'
 * remove_vowels('abcdef') -> 'bcdf'
 * remove_vowels('aaaaa') -> ''
 * remove_vowels('aaBAA') -> 'B'
 * remove_vowels('zbcd') -> 'zbcd'
 *
 * @param {string} text
 * @returns {string}
 */
function removeVowels(text) {","return text
        .split('')
        .filter(s => !['a', 'e', 'i', 'o', 'u'].includes(s.toLowerCase()))
        .join('');
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(''), '');
    assert.strictEqual(candidate(""abcdef\nghijklm""), 'bcdf\nghjklm');
    assert.strictEqual(candidate('fedcba'), 'fdcb');
    assert.strictEqual(candidate('eeeee'), '');
    assert.strictEqual(candidate('acBAA'), 'cB');
    assert.strictEqual(candidate('EcBOO'), 'cB');
    assert.strictEqual(candidate('ybcd'), 'ybcd');
}",removeVowels
112,52,"/**
 * Return true if all numbers in the list l are below threshold t.
 * @param {number[]} l
 * @param {number} t
 * @returns {boolean}
 * @example
 * belowThreshold([1, 2, 4, 10], 100); // true
 * belowThreshold([1, 20, 4, 10], 5); // false
*/
function belowThreshold(l, t) {","for (const e of l) {
        if (e >= t) {
            return false;
        }
    }
    return true;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.ok(candidate([1, 2, 4, 10], 100));
    assert.ok(!candidate([1, 20, 4, 10], 5));
    assert.ok(candidate([1, 20, 4, 10], 21));
    assert.ok(candidate([1, 20, 4, 10], 22));
    assert.ok(candidate([1, 8, 4, 10], 11));
    assert.ok(!candidate([1, 8, 4, 10], 10));
}",belowThreshold
113,53,"/**
 * Add two numbers x and y
 *
 * @example
 * add(2, 3); // 5
 * add(5, 7); // 12
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function add(x, y) {","return x + y;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(0, 1), 1);
    assert.strictEqual(candidate(1, 0), 1);
    assert.strictEqual(candidate(2, 3), 5);
    assert.strictEqual(candidate(5, 7), 12);
    assert.strictEqual(candidate(7, 5), 12);

    for (let i = 0; i < 100; i++) {
        const x = Math.floor(Math.random() * 1001);
        const y = Math.floor(Math.random() * 1001);
        assert.strictEqual(candidate(x, y), x + y);
    }
}",add
114,54,"/**
 * Check if two words have the same characters.
 *
 * @param {string} s0
 * @param {string} s1
 * @returns {boolean}
 *
 * @example
 * sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc'); // true
 * sameChars('abcd', 'dddddddabc'); // true
 * sameChars('dddddddabc', 'abcd'); // true
 * sameChars('eabcd', 'dddddddabc'); // false
 * sameChars('abcd', 'dddddddabce'); // false
 * sameChars('eabcdzzzz', 'dddzzzzzzzddddabc'); // false
 */
function sameChars(s0, s1) {","const set0 = new Set(s0);
    const set1 = new Set(s1);
    if (set0.size !== set1.size) {
        return false;
    }
    for (const ch of set0) {
        if (!set1.has(ch)) {
            return false;
        }
    }
    return true;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true);
    assert.strictEqual(candidate('abcd', 'dddddddabc'), true);
    assert.strictEqual(candidate('dddddddabc', 'abcd'), true);
    assert.strictEqual(candidate('eabcd', 'dddddddabc'), false);
    assert.strictEqual(candidate('abcd', 'dddddddabcf'), false);
    assert.strictEqual(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false);
    assert.strictEqual(candidate('aabb', 'aaccc'), false);
}",sameChars
115,55,"/**
 * Return n-th Fibonacci number.
 *
 * @param {number} n
 * @returns {number}
 * @example
 * fib(10) // 55
 * fib(1) // 1
 * fib(8) // 21
 */
function fib(n) {","if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.ok(candidate(10) === 55);
    assert.ok(candidate(1) === 1);
    assert.ok(candidate(8) === 21);
    assert.ok(candidate(11) === 89);
    assert.ok(candidate(12) === 144);
}",fib
116,56,"/**
 * brackets is a string of ""<"" and "">"".
 * Returns true if every opening bracket has a corresponding closing bracket.
 *
 * @param {string} brackets
 * @returns {boolean}
 *
 * @example
 * correctBracketing(""<"") // false
 * correctBracketing(""<>"") // true
 * correctBracketing(""<<><>>"") // true
 * correctBracketing(""><<>"") // false
 */
function correctBracketing(brackets) {","let depth = 0;
    for (const b of brackets) {
        if (b === ""<"") {
            depth++;
        } else {
            depth--;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth === 0;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.ok(candidate(""<>""));
    assert.ok(candidate(""<<><>>""));
    assert.ok(candidate(""<><><<><>><>""));
    assert.ok(candidate(""<><><<<><><>><>><<><><<>>>""));
    assert.ok(!candidate(""<<<><>>>>""));
    assert.ok(!candidate(""><<>""));
    assert.ok(!candidate(""<""));
    assert.ok(!candidate(""<<<<""));
    assert.ok(!candidate("">""));
    assert.ok(!candidate(""<<>""));
    assert.ok(!candidate(""<><><<><>><>><<>""));
    assert.ok(!candidate(""<><><<><>><>>><>""));
}",correctBracketing
117,57,"/**
 * Return true if array elements are monotonically increasing or decreasing.
 * @param {number[]} arr
 * @returns {boolean}
 */
function monotonic(arr) {","const asc = [...arr].sort((a, b) => a - b);
    const desc = [...arr].sort((a, b) => b - a);
    if (JSON.stringify(arr) === JSON.stringify(asc) || JSON.stringify(arr) === JSON.stringify(desc)) {
        return true;
    }
    return false;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([1, 2, 4, 10]), true);
    assert.strictEqual(candidate([1, 2, 4, 20]), true);
    assert.strictEqual(candidate([1, 20, 4, 10]), false);
    assert.strictEqual(candidate([4, 1, 0, -10]), true);
    assert.strictEqual(candidate([4, 1, 1, 0]), true);
    assert.strictEqual(candidate([1, 2, 3, 2, 5, 60]), false);
    assert.strictEqual(candidate([1, 2, 3, 4, 5, 60]), true);
    assert.strictEqual(candidate([9, 9, 9, 9]), true);
}",monotonic
118,58,"/**
 * Return sorted unique common elements for two lists.
 * @param {number[]} l1
 * @param {number[]} l2
 * @returns {number[]}
 */
function common(l1, l2) {","const ret = new Set();
    for (const e1 of l1) {
        for (const e2 of l2) {
            if (e1 === e2) {
                ret.add(e1);
            }
        }
    }
    return Array.from(ret).sort((a, b) => a - b);
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.deepStrictEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]), [1, 5, 653]);
    assert.deepStrictEqual(candidate([5, 3, 2, 8], [3, 2]), [2, 3]);
    assert.deepStrictEqual(candidate([4, 3, 2, 8], [3, 2, 4]), [2, 3, 4]);
    assert.deepStrictEqual(candidate([4, 3, 2, 8], []), []);
}",common
119,59,"/**
 * Return the largest prime factor of n. Assume n > 1 and is not a prime.
 *
 * @example
 * largestPrimeFactor(13195); // 29
 * @example
 * largestPrimeFactor(2048); // 2
 *
 * @param {number} n
 * @returns {number}
 */
function largestPrimeFactor(n) {","/**
     * Check if k is a prime number.
     * @param {number} k
     * @returns {boolean}
     */
    function isPrime(k) {
        if (k < 2) {
            return false;
        }
        for (let i = 2; i < k; i++) {
            if (k % i === 0) {
                return false;
            }
        }
        return true;
    }

    let largest = 1;
    for (let j = 2; j <= n; j++) {
        if (n % j === 0 && isPrime(j)) {
            largest = Math.max(largest, j);
        }
    }
    return largest;
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(15), 5);
    assert.strictEqual(candidate(27), 3);
    assert.strictEqual(candidate(63), 7);
    assert.strictEqual(candidate(330), 11);
    assert.strictEqual(candidate(13195), 29);
}",largestPrimeFactor
121,60,"/**
 * sum_to_n is a function that sums numbers from 1 to n.
 *
 * @param {number} n - The number up to which to sum.
 * @returns {number} The sum from 1 to n.
 *
 * @example
 * sum_to_n(30); // 465
 * sum_to_n(100); // 5050
 * sum_to_n(5); // 15
 * sum_to_n(10); // 55
 * sum_to_n(1); // 1
 */
function sumToN(n) {","let sum = 0;
    for (let i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}","const METADATA = {};

function check(candidate) {
    console.assert(candidate(1) === 1);
    console.assert(candidate(6) === 21);
    console.assert(candidate(11) === 66);
    console.assert(candidate(30) === 465);
    console.assert(candidate(100) === 5050);
}",sumToN
122,61,"/**
 * brackets is a string of ""("" and "")"".
 * return true if every opening bracket has a corresponding closing bracket.
 *
 * @param {string} brackets
 * @returns {boolean}
 *
 * @example
 * correctBracketing(""(""); // false
 * correctBracketing(""()""); // true
 * correctBracketing(""(()())""); // true
 * correctBracketing("")(()""); // false
 */
function correctBracketing(brackets) {","let depth = 0;
    for (const b of brackets) {
        if (b === '(') {
            depth += 1;
        } else {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth === 0;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert(candidate(""()""));
    assert(candidate(""(()())""));
    assert(candidate(""()()(()())()""));
    assert(candidate(""()()((()()())())(()()(()))""));
    assert(!candidate(""((()())))""));
    assert(!candidate("")(()""));
    assert(!candidate(""(""));
    assert(!candidate(""((((""));
    assert(!candidate("")""));
    assert(!candidate(""(()""));
    assert(!candidate(""()()(()())())(()""));
    assert(!candidate(""()()(()())()))()""));
}",correctBracketing
123,62,"/**
 * xs represent coefficients of a polynomial.
 * xs[0] + xs[1] * x + xs[2] * x^2 + ....
 * Return derivative of this polynomial in the same form.
 * @param {number[]} xs
 * @returns {number[]}
 * @example
 * derivative([3, 1, 2, 4, 5]); // [1, 4, 12, 20]
 * derivative([1, 2, 3]); // [2, 6]
 */
function derivative(xs) {","return xs.map((x, i) => i * x).slice(1);
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.deepStrictEqual(candidate([3, 1, 2, 4, 5]), [1, 4, 12, 20]);
    assert.deepStrictEqual(candidate([1, 2, 3]), [2, 6]);
    assert.deepStrictEqual(candidate([3, 2, 1]), [2, 2]);
    assert.deepStrictEqual(candidate([3, 2, 1, 0, 4]), [2, 2, 0, 16]);
    assert.deepStrictEqual(candidate([1]), []);
}",derivative
124,63,"/**
 * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:
 * fibfib(0) == 0
 * fibfib(1) == 0
 * fibfib(2) == 1
 * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
 * Please write a function to efficiently compute the n-th element of the fibfib number sequence.
 *
 * @example
 * fibfib(1); // 0
 * @example
 * fibfib(5); // 4
 * @example
 * fibfib(8); // 24
 */
function fibfib(n) {","if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 0;
    }
    if (n === 2) {
        return 1;
    }
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    assert.strictEqual(candidate(2), 1);
    assert.strictEqual(candidate(1), 0);
    assert.strictEqual(candidate(5), 4);
    assert.strictEqual(candidate(8), 24);
    assert.strictEqual(candidate(10), 81);
    assert.strictEqual(candidate(12), 274);
    assert.strictEqual(candidate(14), 927);
}",fibfib
125,64,"const FIX = `
Add more test cases.
`;

/**
 * Write a function vowelsCount which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 *
 * Example:
 * >>> vowelsCount(""abcde"")
 * 2
 * >>> vowelsCount(""ACEDY"")
 * 3
 */
function vowelsCount(s) {","const vowels = 'aeiouAEIOU';
  let n_vowels = 0;
  for (const c of s) {
    if (vowels.includes(c)) {
      n_vowels++;
    }
  }
  const last = s[s.length - 1];
  if (last === 'y' || last === 'Y') {
    n_vowels++;
  }
  return n_vowels;
}","const assert = require('assert');
const METADATA = {};


function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate(""abcde""), 2, ""Test 1"");
  assert.strictEqual(candidate(""Alone""), 3, ""Test 2"");
  assert.strictEqual(candidate(""key""), 2, ""Test 3"");
  assert.strictEqual(candidate(""bye""), 1, ""Test 4"");
  assert.strictEqual(candidate(""keY""), 2, ""Test 5"");
  assert.strictEqual(candidate(""bYe""), 1, ""Test 6"");
  assert.strictEqual(candidate(""ACEDY""), 3, ""Test 7"");

  // Check some edge cases that are easy to work out by hand.
  assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",vowelsCount
126,65,"/**
 * Circular shift the digits of the integer x, shift the digits right by shift
 * and return the result as a string.
 * If shift > number of digits, return digits reversed.
 * @example
 * circularShift(12, 1) // ""21""
 * circularShift(12, 2) // ""12""
 * @param {number} x - The integer whose digits will be shifted.
 * @param {number} shift - The number of positions to shift the digits to the right.
 * @returns {string} - The resulting string after circular shift or reverse.
 */
function circularShift(x, shift) {","const s = String(x);
    if (shift > s.length) {
        return s.split('').reverse().join('');
    } else {
        return s.slice(s.length - shift) + s.slice(0, s.length - shift);
    }
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(100, 2), ""001"");
    assert.strictEqual(candidate(12, 2), ""12"");
    assert.strictEqual(candidate(97, 8), ""79"");
    assert.strictEqual(candidate(12, 1), ""21"", ""This prints if this assert fails 1 (good for debugging!)"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(11, 101), ""11"", ""This prints if this assert fails 2 (also good for debugging!)"");
}",circularShift
127,66,"/**
 * Task
 * Write a function that takes a string as input and returns the sum of the upper characters only'
 * ASCII codes.
 *
 * Examples:
 *     digitSum("""") => 0
 *     digitSum(""abAB"") => 131
 *     digitSum(""abcCd"") => 67
 *     digitSum(""helloE"") => 69
 *     digitSum(""woArBld"") => 131
 *     digitSum(""aAaaaXa"") => 153
 */
function digitSum(s) {","if (s === """") return 0;
    let sum = 0;
    for (const char of s) {
        if (char >= 'A' && char <= 'Z') {
            sum += char.charCodeAt(0);
        }
    }
    return sum;
}","const assert = require('assert');
function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(""""), 0, ""Error"");
    assert.strictEqual(candidate(""abAB""), 131, ""Error"");
    assert.strictEqual(candidate(""abcCd""), 67, ""Error"");
    assert.strictEqual(candidate(""helloE""), 69, ""Error"");
    assert.strictEqual(candidate(""woArBld""), 131, ""Error"");
    assert.strictEqual(candidate(""aAaaaXa""), 153, ""Error"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate("" How are yOu?""), 151, ""Error"");
    assert.strictEqual(candidate(""You arE Very Smart""), 327, ""Error"");
}",digitSum
128,67,"/**
 * In this task, you will be given a string that represents a number of apples and oranges
 * that are distributed in a basket of fruit. This basket contains apples, oranges, and mango fruits.
 * Given the string that represents the total number of the oranges and apples and an integer that
 * represents the total number of the fruits in the basket, return the number of mango fruits in the basket.
 *
 * For example:
 * fruit_distribution(""5 apples and 6 oranges"", 19) -> 19 - 5 - 6 = 8
 * fruit_distribution(""0 apples and 1 oranges"", 3) -> 3 - 0 - 1 = 2
 * fruit_distribution(""2 apples and 3 oranges"", 100) -> 100 - 2 - 3 = 95
 * fruit_distribution(""100 apples and 1 oranges"", 120) -> 120 - 100 - 1 = 19
 *
 */
function fruit_distribution(s, n) {","const lis = [];
    s.split(' ').forEach(i => {
        if (/^\d+$/.test(i)) {
            lis.push(parseInt(i, 10));
        }
    });
    return n - lis.reduce((a, b) => a + b, 0);
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(""5 apples and 6 oranges"", 19), 8);
    assert.strictEqual(candidate(""5 apples and 6 oranges"", 21), 10);
    assert.strictEqual(candidate(""0 apples and 1 oranges"", 3), 2);
    assert.strictEqual(candidate(""1 apples and 0 oranges"", 3), 2);
    assert.strictEqual(candidate(""2 apples and 3 oranges"", 100), 95);
    assert.strictEqual(candidate(""2 apples and 3 oranges"", 5), 0);
    assert.strictEqual(candidate(""1 apples and 100 oranges"", 120), 19);
}",fruit_distribution
129,68,"/**
* ""Given an array representing a branch of a tree that has non-negative integer nodes
* your task is to pluck one of the nodes and return it.
* The plucked node should be the node with the smallest even value.
* If multiple nodes with the same smallest even value are found return the node that has smallest index.
*
* The plucked node should be returned in a list, [ smalest_value, its index ],
* If there are no even values or the given array is empty, return [].
*
* Example 1:
*     Input: [4,2,3]
*     Output: [2, 1]
*     Explanation: 2 has the smallest even value, and 2 has the smallest index.
*
* Example 2:
*     Input: [1,2,3]
*     Output: [2, 1]
*     Explanation: 2 has the smallest even value, and 2 has the smallest index. 
*
* Example 3:
*     Input: []
*     Output: []
*   
* Example 4:
*     Input: [5, 0, 3, 0, 4, 2]
*     Output: [0, 1]
*     Explanation: 0 is the smallest value, but  there are two zeros,
*                  so we will choose the first zero, which has the smallest index.
*
* Constraints:
*     * 1 <= nodes.length <= 10000
*     * 0 <= node.value
*/
function pluck(arr) {","if (arr.length === 0) return [];
    const evens = arr.filter(x => x % 2 === 0);
    if (evens.length === 0) return [];
    const minValue = Math.min(...evens);
    return [minValue, arr.indexOf(minValue)];
}","const assert = require('assert');
const METADATA = {};

function check(candidate) {
    // Check some simple cases
    assert.ok(true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([4, 2, 3]), [2, 1], ""Error"");
    assert.deepStrictEqual(candidate([1, 2, 3]), [2, 1], ""Error"");
    assert.deepStrictEqual(candidate([]), [], ""Error"");
    assert.deepStrictEqual(candidate([5, 0, 3, 0, 4, 2]), [0, 1], ""Error"");

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.deepStrictEqual(candidate([1, 2, 3, 0, 5, 3]), [0, 3], ""Error"");
    assert.deepStrictEqual(candidate([5, 4, 8, 4, 8]), [4, 1], ""Error"");
    assert.deepStrictEqual(candidate([7, 6, 7, 1]), [6, 1], ""Error"");
    assert.deepStrictEqual(candidate([7, 9, 7, 1]), [], ""Error"");
}",pluck
130,69,"/**
 * You are given a non-empty list of positive integers. Return the greatest integer that is greater than
 * zero, and has a frequency greater than or equal to the value of the integer itself.
 * The frequency of an integer is the number of times it appears in the list.
 * If no such a value exists, return -1.
 * Examples:
 *   search([4, 1, 2, 2, 3, 1]) == 2
 *   search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
 *   search([5, 5, 4, 4, 4]) == -1
 */
function search(lst) {","const maxVal = Math.max(...lst);
    const frq = new Array(maxVal + 1).fill(0);
    for (const i of lst) {
        frq[i]++;
    }
    let ans = -1;
    for (let i = 1; i < frq.length; i++) {
        if (frq[i] >= i) {
            ans = i;
        }
    }
    return ans;
}","const assert = require('assert');
function check(candidate) {
    // manually generated tests
    assert.strictEqual(candidate([5, 5, 5, 5, 1]), 1);
    assert.strictEqual(candidate([4, 1, 4, 1, 4, 4]), 4);
    assert.strictEqual(candidate([3, 3]), -1);
    assert.strictEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert.strictEqual(candidate([2, 3, 3, 2, 2]), 2);

    // automatically generated tests
    assert.strictEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert.strictEqual(candidate([3, 2, 8, 2]), 2);
    assert.strictEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert.strictEqual(candidate([8, 8, 3, 6, 5, 6, 4]), -1);
    assert.strictEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert.strictEqual(candidate([1, 9, 10, 1, 3]), 1);
    assert.strictEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert.strictEqual(candidate([1]), 1);
    assert.strictEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert.strictEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert.strictEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert.strictEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert.strictEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert.strictEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert.strictEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert.strictEqual(candidate([10]), -1);
    assert.strictEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert.strictEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert.strictEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert.strictEqual(candidate([3, 10, 10, 9, 2]), -1);
}",search
132,70,"/**
 * Given list of integers, return list in strange order.
 * Strange sorting, is when you start with the minimum value,
 * then maximum of the remaining integers, then minimum and so on.
 *
 * Examples:
 * strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]
 * strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]
 * strangeSortList([]) == []
 */
function strangeSortList(lst) {","const res = [];
    let toggle = true;
    const arr = lst.slice();
    while (arr.length > 0) {
        const val = toggle ? Math.min(...arr) : Math.max(...arr);
        res.push(val);
        arr.splice(arr.indexOf(val), 1);
        toggle = !toggle;
    }
    return res;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([1, 2, 3, 4]), [1, 4, 2, 3]);
    assert.deepStrictEqual(candidate([5, 6, 7, 8, 9]), [5, 9, 6, 8, 7]);
    assert.deepStrictEqual(candidate([1, 2, 3, 4, 5]), [1, 5, 2, 4, 3]);
    assert.deepStrictEqual(candidate([5, 6, 7, 8, 9, 1]), [1, 9, 5, 8, 6, 7]);
    assert.deepStrictEqual(candidate([5, 5, 5, 5]), [5, 5, 5, 5]);
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([1,2,3,4,5,6,7,8]), [1, 8, 2, 7, 3, 6, 4, 5]);
    assert.deepStrictEqual(candidate([0,2,2,2,5,5,-5,-5]), [-5, 5, -5, 5, 0, 2, 2, 2]);
    assert.deepStrictEqual(candidate([111111]), [111111]);
    // Check some edge cases that are easy to work out by hand.
    assert(true);
}",strangeSortList
133,71,"/**
 * Given the lengths of the three sides of a triangle. Return the area of
 * the triangle rounded to 2 decimal points if the three sides form a valid triangle.
 * Otherwise return -1.
 * Three sides make a valid triangle when the sum of any two sides is greater
 * than the third side.
 * Example:
 * triangleArea(3, 4, 5) === 6.00
 * triangleArea(1, 2, 10) === -1
 */
function triangleArea(a, b, c) {","if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }
    const s = (a + b + c) / 2;
    const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
    return Math.round(area * 100) / 100;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(3, 4, 5), 6.00, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(1, 2, 10), -1);
    assert.strictEqual(candidate(4, 8, 5), 8.18);
    assert.strictEqual(candidate(2, 2, 2), 1.73);
    assert.strictEqual(candidate(1, 2, 3), -1);
    assert.strictEqual(candidate(10, 5, 7), 16.25);
    assert.strictEqual(candidate(2, 6, 3), -1);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(1, 1, 1), 0.43, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate(2, 2, 10), -1);
}",triangleArea
134,72,"/**
 * Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements
 * is less than or equal to the maximum possible weight w.
 *
 * Example:
 * willItFly([1, 2], 5) ➞ false
 * // 1+2 is less than the maximum possible weight, but it's unbalanced.
 *
 * willItFly([3, 2, 3], 1) ➞ false
 * // it's balanced, but 3+2+3 is more than the maximum possible weight.
 *
 * willItFly([3, 2, 3], 9) ➞ true
 * // 3+2+3 is less than the maximum possible weight, and it's balanced.
 *
 * willItFly([3], 5) ➞ true
 * // 3 is less than the maximum possible weight, and it's balanced.
 */
function willItFly(q, w) {","if (q.reduce((a, b) => a + b, 0) > w) {
        return false;
    }
    let i = 0, j = q.length - 1;
    while (i < j) {
        if (q[i] !== q[j]) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([3, 2, 3], 9), true);
    assert.strictEqual(candidate([1, 2], 5), false);
    assert.strictEqual(candidate([3], 5), true);
    assert.strictEqual(candidate([3, 2, 3], 1), false);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1, 2, 3], 6), false);
    assert.strictEqual(candidate([5], 5), true);
}",willItFly
135,73,"/**
 * Given an array arr of integers, find the minimum number of elements that
 * need to be changed to make the array palindromic. A palindromic array is an array that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 *
 * For example:
 * smallestChange([1,2,3,5,4,7,9,6]) === 4
 * smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1
 * smallestChange([1, 2, 3, 2, 1]) === 0
 */
function smallestChange(arr) {","let ans = 0;
    const n = arr.length;
    for (let i = 0; i < Math.floor(n / 2); i++) {
        if (arr[i] !== arr[n - i - 1]) {
            ans++;
        }
    }
    return ans;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1,2,3,5,4,7,9,6]), 4);
    assert.strictEqual(candidate([1, 2, 3, 4, 3, 2, 2]), 1);
    assert.strictEqual(candidate([1, 4, 2]), 1);
    assert.strictEqual(candidate([1, 4, 4, 2]), 1);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1, 2, 3, 2, 1]), 0);
    assert.strictEqual(candidate([3, 1, 1, 3]), 0);
    assert.strictEqual(candidate([1]), 0);
    assert.strictEqual(candidate([0, 1]), 1);
}",smallestChange
136,74,"/**
* Write a function that accepts two lists of strings and returns the list that has
* total number of chars in the all strings of the list less than the other list.
*
* if the two lists have the same number of chars, return the first list.
*
* Examples:
* totalMatch([], []) ➞ []
* totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']
* totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']
* totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']
* totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']
*/
function totalMatch(lst1, lst2) {","const l1 = lst1.reduce((sum, st) => sum + st.length, 0);
    const l2 = lst2.reduce((sum, st) => sum + st.length, 0);
    
    if (l1 <= l2) {
        return lst1;
    } else {
        return lst2;
    }
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.ok(true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([], []), []);
    assert.deepStrictEqual(candidate(['hi', 'admin'], ['hi', 'hi']), ['hi', 'hi']);
    assert.deepStrictEqual(candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']), ['hi', 'admin']);
    assert.deepStrictEqual(candidate(['4'], ['1', '2', '3', '4', '5']), ['4']);
    assert.deepStrictEqual(candidate(['hi', 'admin'], ['hI', 'Hi']), ['hI', 'Hi']);
    assert.deepStrictEqual(candidate(['hi', 'admin'], ['hI', 'hi', 'hi']), ['hI', 'hi', 'hi']);
    assert.deepStrictEqual(candidate(['hi', 'admin'], ['hI', 'hi', 'hii']), ['hi', 'admin']);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.deepStrictEqual(candidate([], ['this']), []);
    assert.deepStrictEqual(candidate(['this'], []), []);
}",totalMatch
137,75,"/**
 * Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100.
 * Example:
 * isMultiplyPrime(30) === true
 * 30 = 2 * 3 * 5
 */
function isMultiplyPrime(a) {","function is_prime(n) {
        for (let j = 2; j < n; j++) {
            if (n % j === 0) {
                return false;
            }
        }
        return true;
    }

    for (let i = 2; i <= 100; i++) {
        if (!is_prime(i)) continue;
        for (let j = 2; j <= 100; j++) {
            if (!is_prime(j)) continue;
            for (let k = 2; k <= 100; k++) {
                if (!is_prime(k)) continue;
                if (i * j * k === a) return true;
            }
        }
    }
    return false;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.ok(candidate(5) === false);
    assert.ok(candidate(30) === true);
    assert.ok(candidate(8) === true);
    assert.ok(candidate(10) === false);
    assert.ok(candidate(125) === true);
    assert.ok(candidate(3 * 5 * 7) === true);
    assert.ok(candidate(3 * 6 * 7) === false);
    assert.ok(candidate(9 * 9 * 9) === false);
    assert.ok(candidate(11 * 9 * 9) === false);
    assert.ok(candidate(11 * 13 * 7) === true);
}",isMultiplyPrime
138,76,"/**
 * Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int = x
 * For example:
 * isSimplePower(1, 4) => true
 * isSimplePower(2, 2) => true
 * isSimplePower(8, 2) => true
 * isSimplePower(3, 2) => false
 * isSimplePower(3, 1) => false
 * isSimplePower(5, 3) => false
 */
function isSimplePower(x, n) {","if (n === 1) {
        return x === 1;
    }
    let power = 1;
    while (power < x) {
        power *= n;
    }
    return power === x;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(16, 2), true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(143214, 16), false, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(4, 2), true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(9, 3), true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(16, 4), true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(24, 2), false, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(128, 4), false, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(12, 6), false, ""This prints if this assert fails 1 (good for debugging!)"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(1, 1), true, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate(1, 12), true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",isSimplePower
139,77,"/**
 * Write a function that takes an integer a and returns true 
 * if this integer is a cube of some integer number.
 * Note: you may assume the input is always valid.
 * iscube(1) // true
 * iscube(2) // false
 * iscube(-1) // true
 * iscube(64) // true
 * iscube(0) // true
 * iscube(180) // false
 */
function iscube(a) {","a = Math.abs(a);
    return Math.pow(Math.round(Math.pow(a, 1/3)), 3) === a;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(1), true, 'First test error: ' + candidate(1));
    assert.strictEqual(candidate(2), false, 'Second test error: ' + candidate(2));
    assert.strictEqual(candidate(-1), true, 'Third test error: ' + candidate(-1));
    assert.strictEqual(candidate(64), true, 'Fourth test error: ' + candidate(64));
    assert.strictEqual(candidate(180), false, 'Fifth test error: ' + candidate(180));
    assert.strictEqual(candidate(1000), true, 'Sixth test error: ' + candidate(1000));

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(0), true, '1st edge test error: ' + candidate(0));
    assert.strictEqual(candidate(1729), false, '2nd edge test error: ' + candidate(1729));
}",iscube
140,78,"/**
 * You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 *
 * Examples:
 * For num = ""AB"" the output should be 1.
 * For num = ""1077E"" the output should be 2.
 * For num = ""ABED1A33"" the output should be 4.
 * For num = ""123456789ABCDEF0"" the output should be 6.
 * For num = ""2020"" the output should be 2.
 */
function hexKey(num) {","const primes = ['2', '3', '5', '7', 'B', 'D'];
    let total = 0;
    for (let i = 0; i < num.length; i++) {
        if (primes.includes(num[i])) {
            total += 1;
        }
    }
    return total;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(""AB""), 1, ""First test error: "" + candidate(""AB""));
    assert.strictEqual(candidate(""1077E""), 2, ""Second test error: "" + candidate(""1077E""));
    assert.strictEqual(candidate(""ABED1A33""), 4, ""Third test error: "" + candidate(""ABED1A33""));
    assert.strictEqual(candidate(""2020""), 2, ""Fourth test error: "" + candidate(""2020""));
    assert.strictEqual(candidate(""123456789ABCDEF0""), 6, ""Fifth test error: "" + candidate(""123456789ABCDEF0""));
    assert.strictEqual(candidate(""112233445566778899AABBCCDDEEFF00""), 12, ""Sixth test error: "" + candidate(""112233445566778899AABBCCDDEEFF00""));

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([]), 0);
}",hexKey
141,79,"/**
 * You will be given a number in decimal form and your task is to convert it to
 * binary format. The function should return a string, with each character representing a binary
 * number. Each character in the string will be '0' or '1'.
 *
 * There will be an extra couple of characters 'db' at the beginning and at the end of the string.
 * The extra characters are there to help with the format.
 *
 * Examples:
 * decimalToBinary(15)   // returns ""db1111db""
 * decimalToBinary(32)   // returns ""db100000db""
 */
function decimalToBinary(decimal) {","return 'db' + decimal.toString(2) + 'db';
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate(0), 'db0db');
  assert.strictEqual(candidate(32), 'db100000db');
  assert.strictEqual(candidate(103), 'db1100111db');
  assert.strictEqual(candidate(15), 'db1111db', 'This prints if this assert fails 1 (good for debugging!)');
  // Check some edge cases that are easy to work out by hand.
  assert.ok(true, 'This prints if this assert fails 2 (also good for debugging!)');
}",decimalToBinary
143,80,"/**
 * You are given a string s.
 * Your task is to check if the string is happy or not.
 * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * isHappy(a) => False
 * isHappy(aa) => False
 * isHappy(abcd) => True
 * isHappy(aabb) => False
 * isHappy(adb) => True
 * isHappy(xyy) => False
 */
function isHappy(s) {","if (s.length < 3) {
    return false;
  }
  for (let i = 0; i < s.length - 2; i++) {
    if (s[i] === s[i+1] || s[i+1] === s[i+2] || s[i] === s[i+2]) {
      return false;
    }
  }
  return true;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  assert.strictEqual(candidate(""a""), false, ""a"");
  assert.strictEqual(candidate(""aa""), false, ""aa"");
  assert.strictEqual(candidate(""abcd""), true, ""abcd"");
  assert.strictEqual(candidate(""aabb""), false, ""aabb"");
  assert.strictEqual(candidate(""adb""), true, ""adb"");
  assert.strictEqual(candidate(""xyy""), false, ""xyy"");
  assert.strictEqual(candidate(""iopaxpoi""), true, ""iopaxpoi"");
  assert.strictEqual(candidate(""iopaxioi""), false, ""iopaxioi"");
}",isHappy
144,81,"/**
 * It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write
 * a function that can output a list of letter grades using the following table:
 *      GPA       |    Letter grade
 *       4.0                A+
 *     > 3.7                A 
 *     > 3.3                A- 
 *     > 3.0                B+
 *     > 2.7                B 
 *     > 2.3                B-
 *     > 2.0                C+
 *     > 1.7                C
 *     > 1.3                C-
 *     > 1.0                D+ 
 *     > 0.7                D 
 *     > 0.0                D-
 *       0.0                E
 */
function numericalLetterGrade(grades) {","const letterGrade = [];
    for (const gpa of grades) {
        if (gpa === 4.0) {
            letterGrade.push(""A+"");
        } else if (gpa > 3.7) {
            letterGrade.push(""A"");
        } else if (gpa > 3.3) {
            letterGrade.push(""A-"");
        } else if (gpa > 3.0) {
            letterGrade.push(""B+"");
        } else if (gpa > 2.7) {
            letterGrade.push(""B"");
        } else if (gpa > 2.3) {
            letterGrade.push(""B-"");
        } else if (gpa > 2.0) {
            letterGrade.push(""C+"");
        } else if (gpa > 1.7) {
            letterGrade.push(""C"");
        } else if (gpa > 1.3) {
            letterGrade.push(""C-"");
        } else if (gpa > 1.0) {
            letterGrade.push(""D+"");
        } else if (gpa > 0.7) {
            letterGrade.push(""D"");
        } else if (gpa > 0.0) {
            letterGrade.push(""D-"");
        } else {
            letterGrade.push(""E"");
        }
    }
    return letterGrade;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([4.0, 3, 1.7, 2, 3.5]), ['A+', 'B', 'C-', 'C', 'A-']);
    assert.deepStrictEqual(candidate([1.2]), ['D+']);
    assert.deepStrictEqual(candidate([0.5]), ['D-']);
    assert.deepStrictEqual(candidate([0.0]), ['E']);
    assert.deepStrictEqual(candidate([1, 0.3, 1.5, 2.8, 3.3]), ['D', 'D-', 'C-', 'B', 'B+']);
    assert.deepStrictEqual(candidate([0, 0.7]), ['E', 'D-']);
}",numericalLetterGrade
145,82,"/**
 * Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples:
 * primeLength('Hello') === true
 * primeLength('abcdcba') === true
 * primeLength('kittens') === true
 * primeLength('orange') === false
 */
function primeLength(string) {","const l = string.length;
    if (l === 0 || l === 1) {
        return false;
    }
    for (let i = 2; i < l; i++) {
        if (l % i === 0) {
            return false;
        }
    }
    return true;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate('Hello'), true);
    assert.strictEqual(candidate('abcdcba'), true);
    assert.strictEqual(candidate('kittens'), true);
    assert.strictEqual(candidate('orange'), false);
    assert.strictEqual(candidate('wow'), true);
    assert.strictEqual(candidate('world'), true);
    assert.strictEqual(candidate('MadaM'), true);
    assert.strictEqual(candidate('Wow'), true);
    assert.strictEqual(candidate(''), false);
    assert.strictEqual(candidate('HI'), true);
    assert.strictEqual(candidate('go'), true);
    assert.strictEqual(candidate('gogo'), false);
    assert.strictEqual(candidate('aaaaaaaaaaaaaaa'), false);
    // Edge cases
    assert.strictEqual(candidate('Madam'), true);
    assert.strictEqual(candidate('M'), false);
    assert.strictEqual(candidate('0'), false);
}",primeLength
146,83,"/**
 * Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
 */
function startsOneEnds(n) {","if (n === 1) return 1;
    return 18 * Math.pow(10, n - 2);
}","const METADATA = {};
const assert = require(""assert"")

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(1), 1, ""Expected startsOneEnds(1) to equal 1"");
    assert.strictEqual(candidate(2), 18, ""Expected startsOneEnds(2) to equal 18"");
    assert.strictEqual(candidate(3), 180, ""Expected startsOneEnds(3) to equal 180"");
    assert.strictEqual(candidate(4), 1800, ""Expected startsOneEnds(4) to equal 1800"");
    assert.strictEqual(candidate(5), 18000, ""Expected startsOneEnds(5) to equal 18000"");
    // Check some edge cases that are easy to work out by hand.
}",startsOneEnds
147,84,"/**
 * Given a positive integer N, return the total sum of its digits in binary.
 *
 *  
 *  Example
 *      For N = 1000, the sum of digits will be 1 the output should be ""1"".
 *      For N = 150, the sum of digits will be 6 the output should be ""110"".
 *      For N = 147, the sum of digits will be 12 the output should be ""1100"".
 *  
 *  Variables:
 *      @N integer
 *           Constraints: 0 ≤ N ≤ 10000.
 *  Output:
 *       a string of binary number
 */
function solve(N) {","const sum = N.toString().split('').reduce((acc, ch) => acc + Number(ch), 0);
    return sum.toString(2);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(1000), ""1"");
    assert.strictEqual(candidate(150), ""110"");
    assert.strictEqual(candidate(147), ""1100"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(333), ""1001"");
    assert.strictEqual(candidate(963), ""10010"");
}",solve
148,85,"/**
 * Given a non-empty list of integers lst, add the even elements that are at odd indices.
 *
 * Examples:
 *   add([4, 2, 6, 7]) ==> 2
 */
function add(lst) {","return lst.reduce((sum, val, idx) => {
        if (idx % 2 === 1 && val % 2 === 0) {
            return sum + val;
        }
        return sum;
    }, 0);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([4, 88]), 88);
    assert.strictEqual(candidate([4, 5, 6, 7, 2, 122]), 122);
    assert.strictEqual(candidate([4, 0, 6, 7]), 0);
    assert.strictEqual(candidate([4, 4, 6, 8]), 12);
    // Check some edge cases that are easy to work out by hand.
}",add
149,86,"/**
 * Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 *
 * For example:
 * antiShuffle('Hi') returns 'Hi'
 * antiShuffle('hello') returns 'ehllo'
 * antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'
 */
function antiShuffle(s) {","return s
    .split(' ')
    .map(i => i.split('').sort().join(''))
    .join(' ');
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate('Hi'), 'Hi');
  assert.strictEqual(candidate('hello'), 'ehllo');
  assert.strictEqual(candidate('number'), 'bemnru');
  assert.strictEqual(candidate('abcd'), 'abcd');
  assert.strictEqual(candidate('Hello World!!!'), 'Hello !!!Wdlor');
  assert.strictEqual(candidate(''), '');
  assert.strictEqual(
    candidate('Hi. My name is Mister Robot. How are you?'),
    '.Hi My aemn is Meirst .Rboot How aer ?ouy'
  );
  // Check some edge cases that are easy to work out by hand.
  assert.ok(true);
}",antiShuffle
150,87,"/**
 * You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
*
* Examples:
* getRow([
*   [1,2,3,4,5,6],
*   [1,2,3,4,1,6],
*   [1,2,3,4,5,1]
* ], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
* getRow([], 1) == []
* getRow([[], [1], [1, 2, 3]], 3) == [[2, 2]]
*/
function getRow(lst, x) {","const coords = [];
    for (let i = 0; i < lst.length; i++) {
        for (let j = 0; j < lst[i].length; j++) {
            if (lst[i][j] === x) {
                coords.push([i, j]);
            }
        }
    }
    coords.sort((a, b) => b[1] - a[1]);
    coords.sort((a, b) => a[0] - b[0]);
    return coords;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(
        candidate(
            [
                [1,2,3,4,5,6],
                [1,2,3,4,1,6],
                [1,2,3,4,5,1]
            ],
            1
        ),
        [
            [0, 0], [1, 4], [1, 0], [2, 5], [2, 0]
        ]
    );
    assert.deepStrictEqual(
        candidate(
            [
                [1,2,3,4,5,6],
                [1,2,3,4,5,6],
                [1,2,3,4,5,6],
                [1,2,3,4,5,6],
                [1,2,3,4,5,6],
                [1,2,3,4,5,6]
            ],
            2
        ),
        [
            [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]
        ]
    );
    assert.deepStrictEqual(
        candidate(
            [
                [1,2,3,4,5,6],
                [1,2,3,4,5,6],
                [1,1,3,4,5,6],
                [1,2,1,4,5,6],
                [1,2,3,1,5,6],
                [1,2,3,4,1,6],
                [1,2,3,4,5,1]
            ],
            1
        ),
        [
            [0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],
            [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]
        ]
    );
    assert.deepStrictEqual(candidate([], 1), []);
    assert.deepStrictEqual(candidate([[1]], 2), []);
    assert.deepStrictEqual(candidate([[], [1], [1, 2, 3]], 3), [[2, 2]]);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",getRow
151,88,"/**
 * Given an array of non-negative integers, return a copy of the given array after sorting,
 * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 *
 * Note:
 *  * don't change the given array.
 *
 * Examples:
 *  * sortArray([]) => []
 *  * sortArray([5]) => [5]
 *  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]
 *  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]
 */

function sortArray(array) {","if (array.length === 0) return [];
    const reverse = (array[0] + array[array.length - 1]) % 2 === 0;
    const copy = array.slice();
    return copy.sort((a, b) => reverse ? b - a : a - b);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([5]), [5]);
    assert.deepStrictEqual(candidate([2, 4, 3, 0, 1, 5]), [0, 1, 2, 3, 4, 5]);
    assert.deepStrictEqual(candidate([2, 4, 3, 0, 1, 5, 6]), [6, 5, 4, 3, 2, 1, 0]);

    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate([2, 1]), [1, 2]);
    assert.deepStrictEqual(candidate([15, 42, 87, 32, 11, 0]), [0, 11, 15, 32, 42, 87]);
    assert.deepStrictEqual(candidate([21, 14, 23, 11]), [23, 21, 14, 11]);
}",sortArray
152,89,"/**
 * Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated.
 * The alphabet should be rotated in a manner such that the letters
 * shift down by two multiplied to two places.
 * For example:
 * encrypt('hi') returns 'lm'
 * encrypt('asdfghjkl') returns 'ewhjklnop'
 * encrypt('gf') returns 'kj'
 * encrypt('et') returns 'ix'
 */
function encrypt(s) {","const d = 'abcdefghijklmnopqrstuvwxyz';
    let out = '';
    for (const c of s) {
        if (d.includes(c)) {
            out += d[(d.indexOf(c) + 2 * 2) % 26];
        } else {
            out += c;
        }
    }
    return out;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate('hi'), 'lm', ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate('asdfghjkl'), 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate('gf'), 'kj', ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate('et'), 'ix', ""This prints if this assert fails 1 (good for debugging!)"");

    assert.strictEqual(candidate('faewfawefaewg'), 'jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate('hellomyfriend'), 'lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)"");
    assert.strictEqual(
        candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'),
        'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl',
        ""This prints if this assert fails 3 (good for debugging!)""
    );

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate('a'), 'e', ""This prints if this assert fails 2 (also good for debugging!)"");
}",encrypt
154,90,"/**
 * You are given an array of integers.
 * Write a function nextSmallest() that returns the 2nd smallest element of the array.
 * Return null if there is no such element.
*
* nextSmallest([1, 2, 3, 4, 5]) === 2
* nextSmallest([5, 1, 4, 3, 2]) === 2
* nextSmallest([]) === null
* nextSmallest([1, 1]) === null
*/
function nextSmallest(lst) {","const unique = Array.from(new Set(lst));
    unique.sort((a, b) => a - b);
    return unique.length < 2 ? null : unique[1];
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1, 2, 3, 4, 5]), 2);
    assert.strictEqual(candidate([5, 1, 4, 3, 2]), 2);
    assert.strictEqual(candidate([]), null);
    assert.strictEqual(candidate([1, 1]), null);
    assert.strictEqual(candidate([1, 1, 1, 1, 0]), 1);
    assert.strictEqual(candidate([1, 0**0]), null);
    assert.strictEqual(candidate([-35, 34, 12, -45]), -35);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",nextSmallest
155,91,"/**
 * You'll be given a string of words, and your task is to count the number
 * of boredoms. A boredom is a sentence that starts with the word ""I"".
 * Sentences are delimited by '.', '?' or '!'.
 *
 * @example
 * // 0
 * isBored(""Hello world"");
 * @example
 * // 1
 * isBored(""The sky is blue. The sun is shining. I love this weather"");
 */
function isBored(S) {","const sentences = S.split(/[.?!]\s*/);
    return sentences.reduce((count, sentence) => count + (sentence.slice(0, 2) === 'I ' ? 1 : 0), 0);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""Hello world""), 0, ""Test 1"");
    assert.strictEqual(candidate(""Is the sky blue?""), 0, ""Test 2"");
    assert.strictEqual(candidate(""I love It !""), 1, ""Test 3"");
    assert.strictEqual(candidate(""bIt""), 0, ""Test 4"");
    assert.strictEqual(candidate(""I feel good today. I will be productive. will kill It""), 2, ""Test 5"");
    assert.strictEqual(candidate(""You and I are going for a walk""), 0, ""Test 6"");
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",isBored
156,92,"/**
 * Create a function that takes 3 numbers.
 * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
 * Returns false in any other cases.
 *
 * Examples:
 * anyInt(5, 2, 7) ➞ true
 * anyInt(3, 2, 2) ➞ false
 * anyInt(3, -2, 1) ➞ true
 * anyInt(3.6, -2.2, 2) ➞ false
 */
function anyInt(x, y, z) {","if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {
    if ((x + y === z) || (x + z === y) || (y + z === x)) {
      return true;
    }
    return false;
  }
  return false;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate(2, 3, 1), true, ""This prints if this assert fails 1 (good for debugging!)"");
  assert.strictEqual(candidate(2.5, 2, 3), false, ""This prints if this assert fails 2 (good for debugging!)"");
  assert.strictEqual(candidate(1.5, 5, 3.5), false, ""This prints if this assert fails 3 (good for debugging!)"");
  assert.strictEqual(candidate(2, 6, 2), false, ""This prints if this assert fails 4 (good for debugging!)"");
  assert.strictEqual(candidate(4, 2, 2), true, ""This prints if this assert fails 5 (good for debugging!)"");
  assert.strictEqual(candidate(2.2, 2.2, 2.2), false, ""This prints if this assert fails 6 (good for debugging!)"");
  assert.strictEqual(candidate(-4, 6, 2), true, ""This prints if this assert fails 7 (good for debugging!)"");

  // Check some edge cases that are easy to work out by hand.
  assert.strictEqual(candidate(2, 1, 1), true, ""This prints if this assert fails 8 (also good for debugging!)"");
  assert.strictEqual(candidate(3, 4, 7), true, ""This prints if this assert fails 9 (also good for debugging!)"");
  
  // This test fails in JS because Javascript cannot distinguish between 3.0 and 3
  // Since it drops the decimal part, 3.0 is equal to 3
  // assert.strictEqual(candidate(3.0, 4, 7), false, ""This prints if this assert fails 10 (also good for debugging!)"");
}",anyInt
157,93,"/**
 * Write a function that takes a message, and encodes in such a
 * way that it swaps case of all letters, replaces all vowels in
 * the message with the letter that appears 2 places ahead of that
 * vowel in the english alphabet.
 * Assume only letters.
 * @example
 * // returns 'TGST'
 * encode('test');
 * @example
 * // returns 'tHKS KS C MGSSCGG'
 * encode('This is a message');
 */
function encode(message) {","const vowels = 'aeiouAEIOU';
    const vowelsReplace = {};
    for (const v of vowels) {
        vowelsReplace[v] = String.fromCharCode(v.charCodeAt(0) + 2);
    }
    let result = '';
    for (const ch of message) {
        // swap case
        const swapped = ch === ch.toLowerCase() ? ch.toUpperCase() : ch.toLowerCase();
        // replace vowel if needed
        result += vowelsReplace[swapped] || swapped;
    }
    return result;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate('TEST'), 'tgst', ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate('Mudasir'), 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)"");
    assert.strictEqual(candidate('YES'), 'ygs', ""This prints if this assert fails 3 (good for debugging!)"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate('This is a message'), 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate(""I DoNt KnOw WhAt tO WrItE""), 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)"");
}",encode
158,94,"/**
 * You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 *
 * Examples:
 * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10
 * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25
 * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13
 * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11
 * For lst = [0,81,12,3,1,21] the output should be 3
 * For lst = [0,8,1,2,1,7] the output should be 7
 */
function skjkasdkd(lst) {","function isPrime(n) {
        for (let i = 2, limit = Math.floor(Math.sqrt(n)); i <= limit; i++) {
            if (n % i === 0) {
                return false;
            }
        }
        return true;
    }
    let maxx = 0;
    for (let i = 0; i < lst.length; i++) {
        if (lst[i] > maxx && isPrime(lst[i])) {
            maxx = lst[i];
        }
    }
    const result = String(maxx)
        .split('')
        .reduce((sum, digit) => sum + Number(digit), 0);
    return result;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]), 10);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]), 25);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]), 13);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]), 11);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([0,81,12,3,1,21]), 3);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([0,8,1,2,1,7]), 7);
    assert.strictEqual(candidate([8191]), 19);
    assert.strictEqual(candidate([8191, 123456, 127, 7]), 19);
    assert.strictEqual(candidate([127, 97, 8192]), 10);
}",skjkasdkd
159,95,"/**
 * Given an object, return true if all keys are strings in lower 
 * case or all keys are strings in upper case, else return false.
 * The function should return false if the given object is empty.
 * Examples:
 * checkDictCase({""a"":""apple"", ""b"":""banana""}) should return true.
 * checkDictCase({""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) should return false.
 * checkDictCase({""a"":""apple"", 8:""banana"", ""a"":""apple""}) should return false.
 * checkDictCase({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) should return false.
 * checkDictCase({""STATE"":""NC"", ""ZIP"":""12345"" }) should return true.
 */
function checkDictCase(obj) {","const keys = Object.keys(obj);
  if (keys.length === 0) {
    return false;
  } else {
    let state = 'start';
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (typeof key !== 'string') {
        state = 'mixed';
        break;
      }
      const isUpper = key.toUpperCase() === key && key.toLowerCase() !== key;
      const isLower = key.toLowerCase() === key && key.toUpperCase() !== key;
      if (state === 'start') {
        if (isUpper) {
          state = 'upper';
        } else if (isLower) {
          state = 'lower';
        } else {
          break;
        }
      } else if ((state === 'upper' && !isUpper) || (state === 'lower' && !isLower)) {
        state = 'mixed';
        break;
      } else {
        break;
      }
    }
    return state === 'upper' || state === 'lower';
  }
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  assert(candidate({""p"":""pineapple"", ""b"":""banana""}) === true, ""First test error: "" + candidate({""p"":""pineapple"", ""b"":""banana""}));
  assert(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) === false, ""Second test error: "" + candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}));
  assert(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) === false, ""Third test error: "" + candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}));
  assert(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) === false, ""Fourth test error: "" + candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}));
  assert(candidate({""STATE"":""NC"", ""ZIP"":""12345""}) === true, ""Fifth test error: "" + candidate({""STATE"":""NC"", ""ZIP"":""12345""}));
  assert(candidate({""fruit"":""Orange"", ""taste"":""Sweet""}) === true, ""Fourth test error: "" + candidate({""fruit"":""Orange"", ""taste"":""Sweet""}));
  assert(candidate({}) === false, ""1st edge test error: "" + candidate({}));
}",checkDictCase
160,96,"/**
 * Implement a function that takes a non-negative integer and returns an array of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * countUpTo(5) => [2,3]
 * countUpTo(11) => [2,3,5,7]
 * countUpTo(0) => []
 * countUpTo(20) => [2,3,5,7,11,13,17,19]
 * countUpTo(1) => []
 * countUpTo(18) => [2,3,5,7,11,13,17]
*/
function countUpTo(n) {","const primes = [];
    for (let i = 2; i < n; i++) {
        let isPrime = true;
        for (let j = 2; j < i; j++) {
            if (i % j === 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            primes.push(i);
        }
    }
    return primes;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(5), [2, 3]);
    assert.deepStrictEqual(candidate(6), [2, 3, 5]);
    assert.deepStrictEqual(candidate(7), [2, 3, 5]);
    assert.deepStrictEqual(candidate(10), [2, 3, 5, 7]);
    assert.deepStrictEqual(candidate(0), []);
    assert.deepStrictEqual(candidate(22), [2, 3, 5, 7, 11, 13, 17, 19]);
    assert.deepStrictEqual(candidate(1), []);
    assert.deepStrictEqual(candidate(18), [2, 3, 5, 7, 11, 13, 17]);
    assert.deepStrictEqual(candidate(47), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert.deepStrictEqual(candidate(101), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}",countUpTo
161,97,"/**
 * Complete the function that takes two integers and returns 
 * the product of their unit digits.
 * Assume the input is always valid.
 * Examples:
 * multiply(148, 412) should return 16.
 * multiply(19, 28) should return 72.
 * multiply(2020, 1851) should return 0.
 * multiply(14,-15) should return 20.
 */
function multiply(a, b) {","return Math.abs(a % 10) * Math.abs(b % 10);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(148, 412), 16, ""First test error: "" + candidate(148, 412));
    assert.strictEqual(candidate(19, 28), 72, ""Second test error: "" + candidate(19, 28));
    assert.strictEqual(candidate(2020, 1851), 0, ""Third test error: "" + candidate(2020, 1851));
    assert.strictEqual(candidate(14, -15), 20, ""Fourth test error: "" + candidate(14, -15));
    assert.strictEqual(candidate(76, 67), 42, ""Fifth test error: "" + candidate(76, 67));
    assert.strictEqual(candidate(17, 27), 49, ""Sixth test error: "" + candidate(17, 27));

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(0, 1), 0, ""1st edge test error: "" + candidate(0, 1));
    assert.strictEqual(candidate(0, 0), 0, ""2nd edge test error: "" + candidate(0, 0));
}",multiply
162,98,"/**
 * Given a string s, count the number of uppercase vowels in even indices.
 *
 * For example:
 * count_upper('aBCdEf') returns 1
 * count_upper('abcdefg') returns 0
 * count_upper('dBBE') returns 0
 */
function count_upper(s) {","let count = 0;
    for (let i = 0; i < s.length; i += 2) {
        if (""AEIOU"".includes(s[i])) {
            count++;
        }
    }
    return count;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate('aBCdEf'), 1);
    assert.strictEqual(candidate('abcdefg'), 0);
    assert.strictEqual(candidate('dBBE'), 0);
    assert.strictEqual(candidate('B'), 0);
    assert.strictEqual(candidate('U'), 1);
    assert.strictEqual(candidate(''), 0);
    assert.strictEqual(candidate('EEEE'), 2);
    // Check some edge cases that are easy to work out by hand.
}",count_upper
163,99,"/**
 * Create a function that takes a value (string) representing a number
 * and returns the closest integer to it. If the number is equidistant
 * from two integers, round it away from zero.
 *
 * Examples:
 * closestInteger(""10"") -> 10
 * closestInteger(""15.3"") -> 15
 *
 * Rounding away from zero means that if the given number is equidistant
 * from two integers, the one you should return is the one that is the
 * farthest from zero. For example closestInteger(""14.5"") should
 * return 15 and closestInteger(""-14.5"") should return -15.
 */
function closestInteger(value) {","if ((value.match(/\./g) || []).length === 1) {
        while (value.charAt(value.length - 1) === '0') {
            value = value.slice(0, -1);
        }
    }
    const num = parseFloat(value);
    let res;
    if (value.slice(-2) === '.5') {
        if (num > 0) {
            res = Math.ceil(num);
        } else {
            res = Math.floor(num);
        }
    } else if (value.length > 0) {
        res = Math.round(num);
    } else {
        res = 0;
    }
    return res;
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""10""), 10, ""Test 1"");
    assert.strictEqual(candidate(""14.5""), 15, ""Test 2"");
    assert.strictEqual(candidate(""-15.5""), -16, ""Test 3"");
    assert.strictEqual(candidate(""15.3""), 15, ""Test 4"");
    assert.strictEqual(candidate(""0""), 0, ""Test 0"");
}",closestInteger
3,100,"/**
 * Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 *   - the next odd number if n is odd.
 *   - the next even number if n is even.
 * Return the number of stones in each level in an array, where element at index
 * i represents the number of stones in the level (i+1).
 *
 * Examples:
 * console.log(makeAPile(3)); // [3, 5, 7]
 */
function makeAPile(n) {","return Array.from({ length: n }, (_, i) => n + 2 * i);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(3), [3, 5, 7], 'Test 3');
    assert.deepStrictEqual(candidate(4), [4, 6, 8, 10], 'Test 4');
    assert.deepStrictEqual(candidate(5), [5, 7, 9, 11, 13]);
    assert.deepStrictEqual(candidate(6), [6, 8, 10, 12, 14, 16]);
    assert.deepStrictEqual(candidate(8), [8, 10, 12, 14, 16, 18, 20, 22]);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, 'This prints if this assert fails 2 (also good for debugging!)');
}",makeAPile
4,101,"/**
 * You will be given a string of words separated by commas or spaces. Your task is
 * to split the string into words and return an array of the words.
 *
 * For example:
 * wordsString(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
 * wordsString(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
 */
function wordsString(s) {","if (!s) {
    return [];
  }
  const s_list = [];
  for (const letter of s) {
    if (letter === ',') {
      s_list.push(' ');
    } else {
      s_list.push(letter);
    }
  }
  const str = s_list.join('');
  return str.split(/\s+/).filter(Boolean);
}","const METADATA = {};
const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.deepStrictEqual(candidate(""Hi, my name is John""), [""Hi"", ""my"", ""name"", ""is"", ""John""]);
  assert.deepStrictEqual(candidate(""One, two, three, four, five, six""), [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepStrictEqual(candidate(""Hi, my name""), [""Hi"", ""my"", ""name""]);
  assert.deepStrictEqual(candidate(""One,, two, three, four, five, six,""), [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);

  // Check some edge cases that are easy to work out by hand.
  assert.deepStrictEqual(candidate(""""), []);
  assert.deepStrictEqual(candidate(""ahmed     , gamal""), [""ahmed"", ""gamal""]);
}",wordsString
5,102,"/**
 * This function takes two positive numbers x and y and returns the
 * biggest even integer number that is in the range [x, y] inclusive. If 
 * there's no such number, then the function should return -1.
 *
 * For example:
 * chooseNum(12, 15) = 14
 * chooseNum(13, 12) = -1
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function chooseNum(x, y) {","if (x > y) {
        return -1;
    }
    if (y % 2 === 0) {
        return y;
    }
    if (x === y) {
        return -1;
    }
    return y - 1;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(12, 15), 14);
    assert.strictEqual(candidate(13, 12), -1);
    assert.strictEqual(candidate(33, 12354), 12354);
    assert.strictEqual(candidate(5234, 5233), -1);
    assert.strictEqual(candidate(6, 29), 28);
    assert.strictEqual(candidate(27, 10), -1);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(7, 7), -1);
    assert.strictEqual(candidate(546, 546), 546);
}",chooseNum
6,103,"/**
 * You are given two positive integers n and m, and your task is to compute the
 * average of the integers from n through m (including n and m).
 * Round the answer to the nearest integer and convert that to binary.
 * If n is greater than m, return -1.
 * Example:
 * roundedAvg(1, 5) => ""0b11""
 * roundedAvg(7, 5) => -1
 * roundedAvg(10, 20) => ""0b1111""
 * roundedAvg(20, 33) => ""0b11010""
 * @param {number} n
 * @param {number} m
 * @returns {string|number} The rounded average as a binary string with '0b' prefix, or -1 if n > m.
 */
function roundedAvg(n, m) {","if (m < n) return -1;
  let summation = 0;
  for (let i = n; i <= m; i++) {
    summation += i;
  }
  const count = m - n + 1;
  const avg = summation / count;
  // Python-style round: ties to even
  const fl = Math.floor(avg);
  const diff = avg - fl;
  let rounded;
  if (diff < 0.5) {
    rounded = fl;
  } else if (diff > 0.5) {
    rounded = fl + 1;
  } else {
    rounded = fl % 2 === 0 ? fl : fl + 1;
  }
  return '0b' + rounded.toString(2);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate(1, 5), ""0b11"");
  assert.strictEqual(candidate(7, 13), ""0b1010"");
  assert.strictEqual(candidate(964, 977), ""0b1111001010"");
  assert.strictEqual(candidate(996, 997), ""0b1111100100"");
  assert.strictEqual(candidate(560, 851), ""0b1011000010"");
  assert.strictEqual(candidate(185, 546), ""0b101101110"");
  assert.strictEqual(candidate(362, 496), ""0b110101101"");
  assert.strictEqual(candidate(350, 902), ""0b1001110010"");
  assert.strictEqual(candidate(197, 233), ""0b11010111"");

  // Check some edge cases that are easy to work out by hand.
  assert.strictEqual(candidate(7, 5), -1);
  assert.strictEqual(candidate(5, 1), -1);
  assert.strictEqual(candidate(5, 5), ""0b101"");
}",roundedAvg
7,104,"/**
 * Given a list of positive integers x, return a sorted list of all 
 * elements that hasn't any even digit.
 *
 * Note: Returned list should be sorted in increasing order.
 *
 * For example:
 * uniqueDigits([15, 33, 1422, 1]);
 * // returns [1, 15, 33]
 * uniqueDigits([152, 323, 1422, 10]);
 * // returns []
 *
 * @param {number[]} x
 * @returns {number[]}
 */
function uniqueDigits(x) {","const oddDigitElements = [];
    for (const i of x) {
        if (String(i).split('').every(c => parseInt(c, 10) % 2 === 1)) {
            oddDigitElements.push(i);
        }
    }
    return oddDigitElements.sort((a, b) => a - b);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(JSON.stringify(candidate([15, 33, 1422, 1])), JSON.stringify([1, 15, 33]), new Error(""Test case 1 failed.""));
    assert.strictEqual(JSON.stringify(candidate([152, 323, 1422, 10])), JSON.stringify([]), new Error(""Test case 2 failed.""));
    assert.strictEqual(JSON.stringify(candidate([12345, 2033, 111, 151])), JSON.stringify([111, 151]), new Error(""Test case 3 failed.""));
    assert.strictEqual(JSON.stringify(candidate([135, 103, 31])), JSON.stringify([31, 135]), new Error(""Test case 4 failed.""));
        
    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",uniqueDigits
8,105,"/**
 * Given an array of integers, sort the integers that are between 1 and 9 inclusive,
 * reverse the resulting array, and then replace each digit by its corresponding name from
 * ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"".
 *
 * For example:
 *   arr = [2, 1, 1, 4, 5, 8, 2, 3]
 *         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]
 *         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]
 *   return [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
 *
 *   If the array is empty, return an empty array:
 *   arr = []
 *   return []
 *
 *   If the array has any strange number ignore it:
 *   arr = [1, -1 , 55]
 *         -> sort arr -> [-1, 1, 55]
 *         -> reverse arr -> [55, 1, -1]
 *   return = ['One']
 *
 * @param {number[]} arr
 * @returns {string[]}
 */
function byLength(arr) {","const dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    };
    const sortedArr = arr.slice().sort((a, b) => b - a);
    const newArr = [];
    for (const v of sortedArr) {
        if (dic[v]) {
            newArr.push(dic[v]);
        }
    }
    return newArr;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.ok(true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]), [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error"");
    assert.deepStrictEqual(candidate([]), [], ""Error"");
    assert.deepStrictEqual(candidate([1, -1, 55]), ['One'], ""Error"");

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.deepStrictEqual(candidate([1, -1, 3, 2]), [""Three"", ""Two"", ""One""]);
    assert.deepStrictEqual(candidate([9, 4, 8]), [""Nine"", ""Eight"", ""Four""]);
}",byLength
9,106,"/**
 * Implement the function f that takes n as a parameter,
 * and returns an array of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * f(5) == [1, 2, 6, 24, 15]
 * @param {number} n
 * @returns {number[]}
 */
function f(n) {","const ret = [];
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 0) {
            let x = 1;
            for (let j = 1; j <= i; j++) {
                x *= j;
            }
            ret.push(x);
        } else {
            let x = 0;
            for (let j = 1; j <= i; j++) {
                x += j;
            }
            ret.push(x);
        }
    }
    return ret;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(5), [1, 2, 6, 24, 15]);
    assert.deepStrictEqual(candidate(7), [1, 2, 6, 24, 15, 720, 28]);
    assert.deepStrictEqual(candidate(1), [1]);
    assert.deepStrictEqual(candidate(3), [1, 2, 6]);
}",f
10,107,"/**
 * Given a positive integer n, return an array that has the number of
 * even and odd integer palindromes that fall within the range (1, n), inclusive.
 *
 * Example 1:
 *   Input: 3
 *   Output: [1, 2]
 *   Explanation:
 *     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
 *
 * Example 2:
 *   Input: 12
 *   Output: [4, 6]
 *   Explanation:
 *     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
 *
 * Note:
 *   1. 1 <= n <= 10^3
 *   2. returned array has the number of even and odd integer palindromes respectively.
 *
 * @param {number} n - The upper bound inclusive for checking palindromes.
 * @returns {number[]} An array where the first element is the count of even palindromes,
 *                     and the second element is the count of odd palindromes.
 */
function evenOddPalindrome(n) {","function isPalindrome(num) {
        const s = String(num);
        return s === s.split('').reverse().join('');
    }

    let evenCount = 0;
    let oddCount = 0;

    for (let i = 1; i <= n; i++) {
        if (i % 2 === 1 && isPalindrome(i)) {
            oddCount++;
        } else if (i % 2 === 0 && isPalindrome(i)) {
            evenCount++;
        }
    }
    return [evenCount, oddCount];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(123), [8, 13]);
    assert.deepStrictEqual(candidate(12), [4, 6]);
    assert.deepStrictEqual(candidate(3), [1, 2]);
    assert.deepStrictEqual(candidate(63), [6, 8]);
    assert.deepStrictEqual(candidate(25), [5, 6]);
    assert.deepStrictEqual(candidate(19), [4, 6]);
    assert.deepStrictEqual(candidate(9), [4, 5], 'This prints if this assert fails 1 (good for debugging!)');

    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate(1), [0, 1], 'This prints if this assert fails 2 (also good for debugging!)');
}",evenOddPalindrome
11,108,"/**
 * Write a function countNums which takes an array of integers and returns
 * the number of elements which has a sum of digits > 0.
 * If a number is negative, then its first signed digit will be negative:
 * e.g. -123 has signed digits -1, 2, and 3.
 */
function digitsSum(n) {
  let neg = 1;
  if (n < 0) {
    n = -n;
    neg = -1;
  }
  const digits = Array.from(String(n), Number);
  digits[0] *= neg;
  return digits.reduce((sum, d) => sum + d, 0);
}

/* @param {number[]} arr
 * @returns {number}
 *
 * @example
 * countNums([]) === 0
 * @example
 * countNums([-1, 11, -11]) === 1
 * @example
 * countNums([1, 1, 2]) === 3
 */
function countNums(arr) {","return arr.map(digitsSum).filter(x => x > 0).length;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  assert.strictEqual(candidate([]), 0);
  assert.strictEqual(candidate([-1, -2, 0]), 0);
  assert.strictEqual(candidate([1, 1, 2, -2, 3, 4, 5]), 6);
  assert.strictEqual(candidate([1, 6, 9, -6, 0, 1, 5]), 5);
  assert.strictEqual(candidate([1, 100, 98, -7, 1, -1]), 4);
  assert.strictEqual(candidate([12, 23, 34, -45, -56, 0]), 5);
  assert.strictEqual(candidate([-0, 1 ** 0]), 1);
  assert.strictEqual(candidate([1]), 1);

  assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",countNums
12,109,"/**
 * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The
 * numbers in the array will be randomly ordered. Your task is to determine if
 * it is possible to get an array sorted in non-decreasing order by performing
 * the following operation on the given array:
 * You are allowed to perform right shift operation any number of times.
 *
 * One right shift operation means shifting all elements of the array by one
 * position in the right direction. The last element of the array will be moved to
 * the starting position in the array i.e. 0th index.
 *
 * If it is possible to obtain the sorted array by performing the above operation
 * then return true else return false.
 * If the given array is empty then return true.
 *
 * Note: The given list is guaranteed to have unique elements.
 *
 * For Example:
 *
 * moveOneBall([3, 4, 5, 1, 2]) ==> true
 * Explanation: By performing 2 right shift operations, non-decreasing order can
 * be achieved for the given array.
 * moveOneBall([3, 5, 4, 1, 2]) ==> false
 * Explanation: It is not possible to get non-decreasing order for the given
 * array by performing any number of right shift operations.
 */
function moveOneBall(arr) {","if(arr.length === 0) {
        return true;
    }
    const sorted_array = [...arr].sort((a, b) => a - b);
    const minValue = Math.min(...arr);
    const minIndex = arr.indexOf(minValue);
    const myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));
    for (let i = 0; i < arr.length; i++) {
        if(myArr[i] !== sorted_array[i]) {
            return false;
        }
    }
    return true;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([3, 4, 5, 1, 2]), true);
    assert.strictEqual(candidate([3, 5, 10, 1, 2]), true);
    assert.strictEqual(candidate([4, 3, 1, 2]), false);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([3, 5, 4, 1, 2]), false);
    assert.strictEqual(candidate([]), true);
}",moveOneBall
14,110,"/**
 * In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return ""YES"".
 * Otherwise, return ""NO"".
 * For example:
 * exchange([1, 2, 3, 4], [1, 2, 3, 4]) => ""YES""
 * exchange([1, 2, 3, 4], [1, 5, 3, 4]) => ""NO""
 * It is assumed that the input lists will be non-empty.
 * @param {number[]} lst1
 * @param {number[]} lst2
 * @returns {string} ""YES"" if possible else ""NO""
 */

function exchange(lst1, lst2) {","let odd = 0;
    let even = 0;
    for (const i of lst1) {
        if (i % 2 === 1) {
            odd++;
        }
    }
    for (const i of lst2) {
        if (i % 2 === 0) {
            even++;
        }
    }
    if (even >= odd) {
        return ""YES"";
    }
    return ""NO"";
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]), ""YES"");
    assert.strictEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]), ""NO"");
    assert.strictEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]), ""YES"");
    assert.strictEqual(candidate([5, 7, 3], [2, 6, 4]), ""YES"");
    assert.strictEqual(candidate([5, 7, 3], [2, 6, 3]), ""NO"");
    assert.strictEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]), ""NO"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([100, 200], [200, 200]), ""YES"");
}",exchange
15,111,"/**
 * Given a string representing a space separated lowercase letters, return an object
 * of the letter with the most repetition and containing the corresponding count.
 * If several letters have the same occurrence, return all of them.
 *
 * Example:
 * histogram('a b c') == {a: 1, b: 1, c: 1}
 * histogram('a b b a') == {a: 2, b: 2}
 * histogram('a b c a b') == {a: 2, b: 2}
 * histogram('b b b b a') == {b: 4}
 * histogram('') == {}
 *
 * @param {string} test - space separated lowercase letters
 * @returns {Object.<string, number>} an object mapping the most frequent letters to their counts
 */
function histogram(test) {","const dict1 = {};
    const list1 = test.split("" "");
    let t = 0;
    for (const i of list1) {
        const count = list1.filter(x => x === i).length;
        if (count > t && i !== '') {
            t = count;
        }
    }
    if (t > 0) {
        for (const i of list1) {
            const count = list1.filter(x => x === i).length;
            if (count === t) {
                dict1[i] = t;
            }
        }
    }
    return dict1;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

/**
 * Run tests on candidate function.
 * @param {function(string): Object.<string, number>} candidate
 */
function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate('a b b a'), {a: 2, b: 2}, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate('a b c a b'), {a: 2, b: 2}, ""This prints if this assert fails 2 (good for debugging!)"");
    assert.deepStrictEqual(candidate('a b c d g'), {a: 1, b: 1, c: 1, d: 1, g: 1}, ""This prints if this assert fails 3 (good for debugging!)"");
    assert.deepStrictEqual(candidate('r t g'), {r: 1, t: 1, g: 1}, ""This prints if this assert fails 4 (good for debugging!)"");
    assert.deepStrictEqual(candidate('b b b b a'), {b: 4}, ""This prints if this assert fails 5 (good for debugging!)"");
    assert.deepStrictEqual(candidate('r t g'), {r: 1, t: 1, g: 1}, ""This prints if this assert fails 6 (good for debugging!)"");
    
    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate(''), {}, ""This prints if this assert fails 7 (also good for debugging!)"");
    assert.deepStrictEqual(candidate('a'), {a: 1}, ""This prints if this assert fails 8 (also good for debugging!)"");
}",histogram
16,112,"/**
 * Task
 * We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c
 * then check if the result string is palindrome.
 * A string is called palindrome if it reads the same backward as forward.
 * You should return a tuple containing the result string and True/False for the check.
 * Example
 * For s = ""abcde"", c = ""ae"", the result should be ('bcd', False)
 * For s = ""abcdef"", c = ""b""  the result should be ('acdef', False)
 * For s = ""abcdedcba"", c = ""ab"", the result should be ('cdedc', True)
 *
 * @param {string} s
 * @param {string} c
 * @returns {[string, boolean]}
 */
function reverseDelete(s, c) {","const filtered = s.split('').filter(char => !c.includes(char)).join('');
  const isPal = filtered === filtered.split('').reverse().join('');
  return [filtered, isPal];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  assert.deepStrictEqual(candidate(""abcde"", ""ae""), ['bcd', false]);
  assert.deepStrictEqual(candidate(""abcdef"", ""b""), ['acdef', false]);
  assert.deepStrictEqual(candidate(""abcdedcba"", ""ab""), ['cdedc', true]);
  assert.deepStrictEqual(candidate(""dwik"", ""w""), ['dik', false]);
  assert.deepStrictEqual(candidate(""a"", ""a""), ['', true]);
  assert.deepStrictEqual(candidate(""abcdedcba"", """"), ['abcdedcba', true]);
  assert.deepStrictEqual(candidate(""abcdedcba"", ""v""), ['abcdedcba', true]);
  assert.deepStrictEqual(candidate(""vabba"", ""v""), ['abba', true]);
  assert.deepStrictEqual(candidate(""mamma"", ""mia""), ['', true]);
}",reverseDelete
17,113,"/**
 * Given an array of strings, where each string consists of only digits, return an array.
 * Each element i of the output should be ""the number of odd elements in the
 * string i of the input."" where all the i's should be replaced by the number
 * of odd digits in the i'th string of the input.
 *
 * @param {string[]} lst
 * @returns {string[]}
 *
 * @example
 * oddCount(['1234567']);
 * // [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
 * @example
 * oddCount(['3', '11111111']);
 * // [""the number of odd elements 1n the str1ng 1 of the 1nput."",
 * //  ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
 */
function oddCount(lst) {","const res = [];
    for (const arr of lst) {
        let n = 0;
        for (const d of arr) {
            if (parseInt(d, 10) % 2 === 1) {
                n++;
            }
        }
        res.push(""the number of odd elements "" + n + ""n the str"" + n + ""ng "" + n + "" of the "" + n + ""nput."");
    }
    return res;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(['1234567']), [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1"");
    assert.deepStrictEqual(candidate(['3', '11111111']), [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2"");
    assert.deepStrictEqual(candidate(['271', '137', '314']), [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ], ""Test 3"");
}",oddCount
18,114,"/**
 * Given an array of integers nums, find the minimum sum of any non-empty sub-array
 * of nums.
 * Example:
 *   minSubArraySum([2, 3, 4, 1, 2, 4]) == 1
 *   minSubArraySum([-1, -2, -3]) == -6
 */

/**
 * Finds the minimum subarray sum.
 * @param {number[]} nums - Array of integers.
 * @returns {number} The minimum subarray sum.
 */
function minSubArraySum(nums) {","let max_sum = 0;
    let s = 0;
    for (const num of nums) {
        s += -num;
        if (s < 0) {
            s = 0;
        }
        max_sum = Math.max(s, max_sum);
    }
    if (max_sum === 0) {
        max_sum = Math.max(...nums.map(i => -i));
    }
    return -max_sum;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([2, 3, 4, 1, 2, 4]), 1, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([-1, -2, -3]), -6);
    assert.strictEqual(candidate([-1, -2, -3, 2, -10]), -14);
    assert.strictEqual(candidate([-9999999999999999]), -9999999999999999);
    assert.strictEqual(candidate([0, 10, 20, 1000000]), 0);
    assert.strictEqual(candidate([-1, -2, -3, 10, -5]), -6);
    assert.strictEqual(candidate([100, -1, -2, -3, 10, -5]), -6);
    assert.strictEqual(candidate([10, 11, 13, 8, 3, 4]), 3);
    assert.strictEqual(candidate([100, -33, 32, -1, 0, -2]), -33);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([-10]), -10, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate([7]), 7);
    assert.strictEqual(candidate([1, -1]), -1);
}",minSubArraySum
19,115,"/**
 * You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it,
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 *
 * Example 1:
 *     Input:
 *         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
 *         bucket_capacity : 1
 *     Output: 6
 *
 * Example 2:
 *     Input:
 *         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
 *         bucket_capacity : 2
 *     Output: 5
 *
 * Example 3:
 *     Input:
 *         grid : [[0,0,0], [0,0,0]]
 *         bucket_capacity : 5
 *     Output: 0
 *
 * Constraints:
 *     * all wells have the same length
 *     * 1 <= grid.length <= 10^2
 *     * 1 <= grid[:,1].length <= 10^2
 *     * grid[i][j] -> 0 | 1
 *     * 1 <= capacity <= 10
 */

/**
 * Calculate the total number of times buckets need to be lowered to empty all wells.
 *
 * @param {number[][]} grid - A rectangular grid where each 1 represents a unit of water.
 * @param {number} capacity - The capacity of each bucket.
 * @returns {number} The number of times buckets are lowered.
 */
function maxFill(grid, capacity) {","return grid.reduce(
        (total, row) => total + Math.ceil(row.reduce((sum, v) => sum + v, 0) / capacity),
        0
    );
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(true, true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1), 6, ""Error"");
    assert.strictEqual(candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2), 5, ""Error"");
    assert.strictEqual(candidate([[0,0,0], [0,0,0]], 5), 0, ""Error"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(true, true, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate([[1,1,1,1], [1,1,1,1]], 2), 4, ""Error"");
    assert.strictEqual(candidate([[1,1,1,1], [1,1,1,1]], 9), 2, ""Error"");
}",maxFill
20,116,"/**
 * In this Kata, you have to sort an array of non-negative integers according to
 * number of ones in their binary representation in ascending order.
 * For similar number of ones, sort based on decimal value.
 *
 * It must be implemented like this:
 * sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
 * sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
 * sortArray([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]
 */
function countOnes(x) {
    return x.toString(2).split('').filter(c => c === '1').length;
}

/**
 * @param {number[]} arr
 * @returns {number[]}
 */
function sortArray(arr) {","return arr
        .slice()
        .sort((a, b) => a - b)
        .sort((a, b) => countOnes(a) - countOnes(b));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(true, true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([1,5,2,3,4]), [1, 2, 4, 3, 5]);
    assert.deepStrictEqual(candidate([-2,-3,-4,-5,-6]), [-4, -2, -6, -5, -3]);
    assert.deepStrictEqual(candidate([1,0,2,3,4]), [0, 1, 2, 4, 3]);
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(candidate([2,5,77,4,5,3,5,7,2,3,4]), [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert.deepStrictEqual(candidate([3,6,44,12,32,5]), [32, 3, 5, 6, 12, 44]);
    assert.deepStrictEqual(candidate([2,4,8,16,32]), [2, 4, 8, 16, 32]);
    assert.deepStrictEqual(candidate([2,4,8,16,32]), [2, 4, 8, 16, 32]);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(true, true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",sortArray
21,117,"/**
 * Given a string s and a natural number n, you have been tasked to implement
 * a function that returns an array of all words from string s that contain exactly
 * n consonants, in order these words appear in the string s.
 * If the string s is empty then the function should return an empty array.
 * Note: you may assume the input string contains only letters and spaces.
 * Examples:
 * selectWords(""Mary had a little lamb"", 4) ==> [""little""]
 * selectWords(""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""]
 * selectWords(""simple white space"", 2) ==> []
 * selectWords(""Hello world"", 4) ==> [""world""]
 * selectWords(""Uncle sam"", 3) ==> [""Uncle""]
 */
function selectWords(s, n) {","const result = [];
    if (!s) return result;
    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
    const words = s.split(' ');
    for (const word of words) {
        let nConsonants = 0;
        for (const char of word) {
            if (!vowels.has(char.toLowerCase())) {
                nConsonants++;
            }
        }
        if (nConsonants === n) {
            result.push(word);
        }
    }
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(""Mary had a little lamb"", 4), [""little""], ""First test error: "" + candidate(""Mary had a little lamb"", 4));
    assert.deepStrictEqual(candidate(""Mary had a little lamb"", 3), [""Mary"", ""lamb""], ""Second test error: "" + candidate(""Mary had a little lamb"", 3));
    assert.deepStrictEqual(candidate(""simple white space"", 2), [], ""Third test error: "" + candidate(""simple white space"", 2));
    assert.deepStrictEqual(candidate(""Hello world"", 4), [""world""], ""Fourth test error: "" + candidate(""Hello world"", 4));
    assert.deepStrictEqual(candidate(""Uncle sam"", 3), [""Uncle""], ""Fifth test error: "" + candidate(""Uncle sam"", 3));
    assert.deepStrictEqual(candidate("""", 4), [], ""1st edge test error: "" + candidate("""", 4));
    assert.deepStrictEqual(candidate(""a b c d e f"", 1), [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + candidate(""a b c d e f"", 1));
}",selectWords
22,118,"/**
 * You are given a word. Your task is to find the closest vowel that stands between
 * two consonants from the right side of the word (case sensitive).
 *
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel that meets the above condition.
 *
 * You may assume that the given string contains English letters only.
 *
 * Example:
 * getClosestVowel(""yogurt"") ==> ""u""
 * getClosestVowel(""FULL"") ==> ""U""
 * getClosestVowel(""quick"") ==> """"
 * getClosestVowel(""ab"") ==> """"
 *
 * @param {string} word
 * @returns {string}
 */
function getClosestVowel(word) {","if (word.length < 3) {
        return """";
    }
    const vowels = new Set([""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]);
    for (let i = word.length - 2; i > 0; i--) {
        const char = word[i];
        if (vowels.has(char)) {
            const prev = word[i - 1];
            const next = word[i + 1];
            if (!vowels.has(prev) && !vowels.has(next)) {
                return char;
            }
        }
    }
    return """";
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""yogurt""), ""u"");
    assert.strictEqual(candidate(""full""), ""u"");
    assert.strictEqual(candidate(""easy""), """");
    assert.strictEqual(candidate(""eAsy""), """");
    assert.strictEqual(candidate(""ali""), """");
    assert.strictEqual(candidate(""bad""), ""a"");
    assert.strictEqual(candidate(""most""), ""o"");
    assert.strictEqual(candidate(""ab""), """");
    assert.strictEqual(candidate(""ba""), """");
    assert.strictEqual(candidate(""quick""), """");
    assert.strictEqual(candidate(""anime""), ""i"");
    assert.strictEqual(candidate(""Asia""), """");
    assert.strictEqual(candidate(""Above""), ""o"");
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(true, true);
}",getClosestVowel
23,119,"/**
 * You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 *
 * Examples:
 * matchParens(['()(', ')']) == 'Yes'
 * matchParens([')', ')']) == 'No'
 */
function matchParens(lst) {","function check(s) {
        let val = 0;
        for (const ch of s) {
            if (ch === '(') {
                val += 1;
            } else {
                val -= 1;
            }
            if (val < 0) {
                return false;
            }
        }
        return val === 0;
    }
    const S1 = lst[0] + lst[1];
    const S2 = lst[1] + lst[0];
    return (check(S1) || check(S2)) ? 'Yes' : 'No';
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(['()(', ')']), 'Yes');
    assert.strictEqual(candidate([')', ')']), 'No');
    assert.strictEqual(candidate(['(()(())', '())())']), 'No');
    assert.strictEqual(candidate([')())', '(()()(']), 'Yes');
    assert.strictEqual(candidate(['(())))', '(()())((']), 'Yes');
    assert.strictEqual(candidate(['()', '())']), 'No');
    assert.strictEqual(candidate(['(()(', '()))()']), 'Yes');
    assert.strictEqual(candidate(['((((', '((())']), 'No');
    assert.strictEqual(candidate([')(()', '(()(']), 'No');
    assert.strictEqual(candidate([')(', ')(']), 'No');

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(['(', ')']), 'Yes');
    assert.strictEqual(candidate([')', '(']), 'Yes');
}",matchParens
25,120,"/**
 * Given an array `arr` of integers and a positive integer `k`, return a sorted list
 * of length `k` with the maximum `k` numbers in `arr`.
 *
 * Example 1:
 *   Input: arr = [-3, -4, 5], k = 3
 *   Output: [-4, -3, 5]
 *
 * Example 2:
 *   Input: arr = [4, -4, 4], k = 2
 *   Output: [4, 4]
 *
 * Example 3:
 *   Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
 *   Output: [2]
 *
 * Note:
 *   1. The length of the array will be in the range of [1, 1000].
 *   2. The elements in the array will be in the range of [-1000, 1000].
 *   3. 0 <= k <= arr.length
 *
 * @param {number[]} arr
 * @param {number} k
 * @returns {number[]}
 */
function maximum(arr, k) {","if (k === 0) {
        return [];
    }
    arr.sort((a, b) => a - b);
    return arr.slice(-k);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([-3, -4, 5], 3), [-4, -3, 5]);
    assert.deepStrictEqual(candidate([4, -4, 4], 2), [4, 4]);
    assert.deepStrictEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1), [2]);
    assert.deepStrictEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3), [2, 20, 123]);
    assert.deepStrictEqual(candidate([-123, 20, 0, 1, 2, -3], 4), [0, 1, 2, 20]);
    assert.deepStrictEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7), [-13, -8, 0, 0, 3, 5, 15]);
    assert.deepStrictEqual(candidate([-1, 0, 2, 5, 3, -10], 2), [3, 5]);
    assert.deepStrictEqual(candidate([1, 0, 5, -7], 1), [5]);
    assert.deepStrictEqual(candidate([4, -4], 2), [-4, 4]);
    assert.deepStrictEqual(candidate([-10, 10], 2), [-10, 10]);
    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0), []);
}",maximum
26,121,"/**
 * Given a non-empty array of integers, return the sum of all of the odd elements that are in even positions.
 *
 * Examples:
 * solution([5, 8, 7, 1]) ==> 12
 * solution([3, 3, 3, 3, 3]) ==> 9
 * solution([30, 13, 24, 321]) ==> 0
 *
 * @param {number[]} lst
 * @returns {number}
 */
function solution(lst) {","return lst.reduce((sum, x, idx) => (idx % 2 === 0 && x % 2 === 1 ? sum + x : sum), 0);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([5, 8, 7, 1]), 12);
    assert.strictEqual(candidate([3, 3, 3, 3, 3]), 9);
    assert.strictEqual(candidate([30, 13, 24, 321]), 0);
    assert.strictEqual(candidate([5, 9]), 5);
    assert.strictEqual(candidate([2, 4, 8]), 0);
    assert.strictEqual(candidate([30, 13, 23, 32]), 23);
    assert.strictEqual(candidate([3, 13, 2, 9]), 3);
}",solution
27,122,"/**
 * Given a non-empty array of integers arr and an integer k, return
 * the sum of the elements with at most two digits from the first k elements of arr.
 *
 * Example:
 *   Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4
 *   Output: 24 // sum of 21 + 3
 *
 * Constraints:
 *   1. 1 <= arr.length <= 100
 *   2. 1 <= k <= arr.length
 *
 * @param {number[]} arr
 * @param {number} k
 * @returns {number}
 */
function addElements(arr, k) {","return arr.slice(0, k)
        .filter(elem => String(elem).length <= 2)
        .reduce((sum, elem) => sum + elem, 0);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert.strictEqual(candidate([111, 121, 3, 4000, 5, 6], 2), 0);
    assert.strictEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert.strictEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24, ""This prints if this assert fails 1 (good for debugging!)"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1], 1), 1, ""This prints if this assert fails 2 (also good for debugging!)"");
}",addElements
28,123,"/**
 * Given a positive integer n, return a sorted array that has the odd numbers in Collatz sequence.
 *
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 *
 * Note:
 *   1. Collatz(1) is [1].
 *   2. returned list sorted in increasing order.
 *
 * For example:
 * getOddCollatz(5) returns [1, 5] // The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1 and 5.
 *
 * @param {number} n
 * @returns {number[]}
 */
function getOddCollatz(n) {","let oddCollatz;
    if (n % 2 === 0) {
        oddCollatz = [];
    } else {
        oddCollatz = [n];
    }
    while (n > 1) {
        if (n % 2 === 0) {
            n = n / 2;
        } else {
            n = n * 3 + 1;
        }
        if (n % 2 === 1) {
            oddCollatz.push(n);
        }
    }
    return oddCollatz.sort((a, b) => a - b);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(14), [1, 5, 7, 11, 13, 17]);
    assert.deepStrictEqual(candidate(5), [1, 5]);
    assert.deepStrictEqual(candidate(12), [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)"");
    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate(1), [1], ""This prints if this assert fails 2 (also good for debugging!)"");
}",getOddCollatz
29,124,"/**
 * You have to write a function which validates a given date string and
 * returns true if the date is valid otherwise false.
 * The date is valid if all of the following rules are satisfied:
 * 1. The date string is not empty.
 * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.
 *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.
 *    And the number of days is not less than 1 or higher than 29 for the month 2.
 * 3. The months should not be less than 1 or higher than 12.
 * 4. The date should be in the format: mm-dd-yyyy
 *
 * @param {string} date
 * @returns {boolean}
 */
function validDate(date) {","try {
        const str = date.trim();
        const parts = str.split('-');
        if (parts.length !== 3) return false;
        const month = parseInt(parts[0], 10);
        const day = parseInt(parts[1], 10);
        const year = parseInt(parts[2], 10);
        if (isNaN(month) || isNaN(day) || isNaN(year)) return false;
        if (month < 1 || month > 12) return false;
        let maxDay = 31;
        if ([4, 6, 9, 11].includes(month)) {
            maxDay = 30;
        } else if (month === 2) {
            maxDay = 29;
        }
        if (day < 1 || day > maxDay) return false;
    } catch (e) {
        return false;
    }
    return true;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate('03-11-2000'), true);
    assert.strictEqual(candidate('15-01-2012'), false);
    assert.strictEqual(candidate('04-0-2040'), false);
    assert.strictEqual(candidate('06-04-2020'), true);
    assert.strictEqual(candidate('01-01-2007'), true);
    assert.strictEqual(candidate('03-32-2011'), false);
    assert.strictEqual(candidate(''), false);
    assert.strictEqual(candidate('04-31-3000'), false);
    assert.strictEqual(candidate('06-06-2005'), true);
    assert.strictEqual(candidate('21-31-2000'), false);
    assert.strictEqual(candidate('04-12-2003'), true);
    assert.strictEqual(candidate('04122003'), false);
    assert.strictEqual(candidate('20030412'), false);
    assert.strictEqual(candidate('2003-04'), false);
    assert.strictEqual(candidate('2003-04-12'), false);
    assert.strictEqual(candidate('04-2003'), false);
}",validDate
30,125,"/**
 * Given a string of words, return an array of words split on whitespace.
 * If no whitespace exists, split on commas ','.
 * If no commas exist, return the number of lowercase letters whose ASCII code is even.
 * ASCII codes: 'a' = 97, 'b' = 98, ..., 'z' = 122
 *
 * Examples:
 * splitWords(""Hello world!"") ➞ [""Hello"", ""world!""]
 * splitWords(""Hello,world!"") ➞ [""Hello"", ""world!""]
 * splitWords(""abcdef"") ➞ 3
 *
 * @param {string} txt
 * @returns {string[]|number}
 */

function splitWords(txt) {","if (txt.includes(' ')) {
        return txt.split(/\s+/);
    } else if (txt.includes(',')) {
        return txt.replace(/,/g, ' ').split(/\s+/);
    } else {
        let count = 0;
        for (let char of txt) {
            const code = char.charCodeAt(0);
            if (char >= 'a' && char <= 'z' && code % 2 === 0) {
                count++;
            }
        }
        return count;
    }
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate(""Hello world!""), [""Hello"", ""world!""]);
    assert.deepStrictEqual(candidate(""Hello,world!""), [""Hello"", ""world!""]);
    assert.deepStrictEqual(candidate(""Hello world,!""), [""Hello"", ""world,!""]);
    assert.deepStrictEqual(candidate(""Hello,Hello,world !""), [""Hello,Hello,world"", ""!""]);
    assert.strictEqual(candidate(""abcdef""), 3);
    assert.strictEqual(candidate(""aaabb""), 2);
    assert.strictEqual(candidate(""aaaBb""), 1);
    assert.strictEqual(candidate(""""), 0);
}",splitWords
31,126,"/**
 * Given an array of numbers, return whether or not they are sorted
 * in ascending order. If array has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 *
 * Examples:
 * isSorted([5]) => true
 * isSorted([1, 2, 3, 4, 5]) => true
 * isSorted([1, 3, 2, 4, 5]) => false
 * isSorted([1, 2, 3, 4, 5, 6]) => true
 * isSorted([1, 2, 3, 4, 5, 6, 7]) => true
 * isSorted([1, 3, 2, 4, 5, 6, 7]) => false
 * isSorted([1, 2, 2, 3, 3, 4]) => true
 * isSorted([1, 2, 2, 2, 3, 4]) => false
 */
function isSorted(lst) {","const countDigit = {};
  for (const i of lst) {
    countDigit[i] = 0;
  }

  for (const i of lst) {
    countDigit[i]++;
  }

  for (const i of lst) {
    if (countDigit[i] > 2) {
      return false;
    }
  }
  
  for (let index = 1; index < lst.length; index++) {
    if (lst[index - 1] > lst[index]) {
      return false;
    }
  }
  return true;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate([5]), true);
  assert.strictEqual(candidate([1, 2, 3, 4, 5]), true);
  assert.strictEqual(candidate([1, 3, 2, 4, 5]), false);
  assert.strictEqual(candidate([1, 2, 3, 4, 5, 6]), true);
  assert.strictEqual(candidate([1, 2, 3, 4, 5, 6, 7]), true);
  assert.strictEqual(candidate([1, 3, 2, 4, 5, 6, 7]), false, ""This prints if this assert fails 1 (good for debugging!)"");
  assert.strictEqual(candidate([]), true, ""This prints if this assert fails 2 (good for debugging!)"");
  assert.strictEqual(candidate([1]), true, ""This prints if this assert fails 3 (good for debugging!)"");
  assert.strictEqual(candidate([3, 2, 1]), false, ""This prints if this assert fails 4 (good for debugging!)"");

  // Check some edge cases that are easy to work out by hand.
  assert.strictEqual(candidate([1, 2, 2, 2, 3, 4]), false, ""This prints if this assert fails 5 (good for debugging!)"");
  assert.strictEqual(candidate([1, 2, 3, 3, 3, 4]), false, ""This prints if this assert fails 6 (good for debugging!)"");
  assert.strictEqual(candidate([1, 2, 2, 3, 3, 4]), true, ""This prints if this assert fails 7 (good for debugging!)"");
  assert.strictEqual(candidate([1, 2, 3, 4]), true, ""This prints if this assert fails 8 (good for debugging!)"");
}",isSorted
32,127,"/**
 * You are given two intervals,
 * where each interval is a pair of integers. For example, interval = [start, end] = [1, 2].
 * The given intervals are closed which means that the interval [start, end]
 * includes both start and end.
 * For each given interval, it is assumed that its start is less or equal its end.
 * Your task is to determine whether the length of intersection of these two
 * intervals is a prime number.
 * Example, the intersection of the intervals [1, 3], [2, 4] is [2, 3]
 * whose length is 1, which is not a prime number.
 * If the length of the intersection is a prime number, return ""YES"",
 * otherwise, return ""NO"".
 * If the two intervals don't intersect, return ""NO"".
 *
 * [input/output] samples:
 * intersection([1, 2], [2, 3]) ==> ""NO""
 * intersection([-1, 1], [0, 4]) ==> ""NO""
 * intersection([-3, -1], [-5, 5]) ==> ""YES""
 */

/**
 * Check if a number is prime.
 * @param {number} num
 * @returns {boolean}
 */
function isPrime(num) {
    if (num === 1 || num === 0) {
        return false;
    }
    if (num === 2) {
        return true;
    }
    for (let i = 2; i < num; i++) {
        if (num % i === 0) {
            return false;
        }
    }
    return true;
}

/**
 * Determine if the length of intersection of two intervals is prime.
 * @param {[number, number]} interval1
 * @param {[number, number]} interval2
 * @returns {string} ""YES"" if prime length, otherwise ""NO""
 */
function intersection(interval1, interval2) {","const l = Math.max(interval1[0], interval2[0]);
    const r = Math.min(interval1[1], interval2[1]);
    const length = r - l;
    if(length > 0 && isPrime(length)) {
        return ""YES"";
    }
    return ""NO"";
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1, 2], [2, 3]), ""NO"");
    assert.strictEqual(candidate([-1, 1], [0, 4]), ""NO"");
    assert.strictEqual(candidate([-3, -1], [-5, 5]), ""YES"");
    assert.strictEqual(candidate([-2, 2], [-4, 0]), ""YES"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([-11, 2], [-1, -1]), ""NO"");
    assert.strictEqual(candidate([1, 2], [3, 5]), ""NO"");
    assert.strictEqual(candidate([1, 2], [1, 2]), ""NO"");
    assert.strictEqual(candidate([-2, -2], [-3, -2]), ""NO"");
}",intersection
33,128,"/**
 * You are given an array arr of integers and you need to return
 * sum of magnitudes of integers multiplied by product of all signs
 * of each number in the array, represented by 1, -1 or 0.
 * Note: return null for empty arr.
 *
 * Example:
 * >>> prodSigns([1, 2, 2, -4]) , -9
 * >>> prodSigns([0, 1]) , 0
 * >>> prodSigns([]) , null
 */
function prodSigns(arr) {","if (!arr || arr.length === 0) return null;
    const prod = arr.includes(0) ? 0 : (-1) ** arr.filter(x => x < 0).length;
    return prod * arr.reduce((sum, i) => sum + Math.abs(i), 0);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(true, true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([1, 2, 2, -4]), -9);
    assert.strictEqual(candidate([0, 1]), 0);
    assert.strictEqual(candidate([1, 1, 1, 2, 3, -1, 1]) , -10);
    assert.strictEqual(candidate([]), null);
    assert.strictEqual(candidate([2, 4, 1, 2, -1, -1, 9]), 20);
    assert.strictEqual(candidate([-1, 1, -1, 1]), 4);
    assert.strictEqual(candidate([-1, 1, 1, 1]), -4);
    assert.strictEqual(candidate([-1, 1, 1, 0]), 0);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(true, true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",prodSigns
34,129,"/**
 * Given a grid with N rows and N columns (N >= 2) and a positive integer k,
 * each cell of the grid contains a value. Every integer in the range [1, N * N]
 * inclusive appears exactly once on the cells of the grid.
 *
 * You have to find the minimum path of length k in the grid. You can start
 * from any cell, and in each step you can move to any of the neighbor cells,
 * in other words, you can go to cells which share an edge with you current
 * cell.
 * Please note that a path of length k means visiting exactly k cells (not
 * necessarily distinct).
 * You CANNOT go off the grid.
 * A path A (of length k) is considered less than a path B (of length k) if
 * after making the ordered lists of the values on the cells that A and B go
 * through (let's call them lst_A and lst_B), lst_A is lexicographically less
 * than lst_B, in other words, there exist an integer index i (1 <= i <= k)
 * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
 * lst_A[j] = lst_B[j].
 * It is guaranteed that the answer is unique.
 * Return an ordered list of the values on the cells that the minimum path go through.
 *
 * Examples:
 *     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3
 *     Output: [1, 2, 1]
 *
 *     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1
 *     Output: [1]
 */
function minPath(grid, k) {","const n = grid.length;
    let val = n * n + 1;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                const temp = [];
                if (i !== 0) {
                    temp.push(grid[i - 1][j]);
                }
                if (j !== 0) {
                    temp.push(grid[i][j - 1]);
                }
                if (i !== n - 1) {
                    temp.push(grid[i + 1][j]);
                }
                if (j !== n - 1) {
                    temp.push(grid[i][j + 1]);
                }
                val = Math.min(...temp);
            }
        }
    }
    const ans = [];
    for (let i = 0; i < k; i++) {
        if (i % 2 === 0) {
            ans.push(1);
        } else {
            ans.push(val);
        }
    }
    return ans;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3), [1, 2, 1]);
    assert.deepStrictEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1), [1]);
    assert.deepStrictEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4), [1, 2, 1, 2]);
    assert.deepStrictEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7), [1, 10, 1, 10, 1, 10, 1]);
    assert.deepStrictEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5), [1, 7, 1, 7, 1]);
    assert.deepStrictEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9), [1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert.deepStrictEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12), [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert.deepStrictEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8), [1, 3, 1, 3, 1, 3, 1, 3]);
    assert.deepStrictEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8), [1, 5, 1, 5, 1, 5, 1, 5]);
    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate([[1, 2], [3, 4]], 10), [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert.deepStrictEqual(candidate([[1, 3], [3, 2]], 10), [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}",minPath
36,130,"/**
 * Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 *        = 2 + 3 + 3 = 8
 * You are given a non-negative integer number n, you have to return a list of the
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * tri(3) = [1, 3, 2, 8]
 */
function tri(n) {","if (n === 0) {
        return [1];
    }
    const myTri = [1, 3];
    for (let i = 2; i <= n; i++) {
        if (i % 2 === 0) {
            myTri.push(i / 2 + 1);
        } else {
            myTri.push(myTri[i - 1] + myTri[i - 2] + (i + 3) / 2);
        }
    }
    return myTri;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(3), [1, 3, 2, 8]);
    assert.deepStrictEqual(candidate(4), [1, 3, 2, 8, 3]);
    assert.deepStrictEqual(candidate(5), [1, 3, 2, 8, 3, 15]);
    assert.deepStrictEqual(candidate(6), [1, 3, 2, 8, 3, 15, 4]);
    assert.deepStrictEqual(candidate(7), [1, 3, 2, 8, 3, 15, 4, 24]);
    assert.deepStrictEqual(candidate(8), [1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert.deepStrictEqual(candidate(9), [1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert.deepStrictEqual(candidate(20), [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate(0), [1]);
    assert.deepStrictEqual(candidate(1), [1, 3]);
}",tri
37,131,"/**
 * Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 *
 * For example:
 * digits(1)  == 1
 * digits(4)  == 0
 * digits(235) == 15
 *
 * @param {number} n
 * @returns {number}
 */
function digits(n) {","let product = 1;
    let oddCount = 0;
    for (const char of n.toString()) {
        const digit = parseInt(char, 10);
        if (digit % 2 === 1) {
            product *= digit;
            oddCount++;
        }
    }
    return oddCount === 0 ? 0 : product;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(5), 5);
    assert.strictEqual(candidate(54), 5);
    assert.strictEqual(candidate(120), 1);
    assert.strictEqual(candidate(5014), 5);
    assert.strictEqual(candidate(98765), 315);
    assert.strictEqual(candidate(5576543), 2625);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(2468), 0);
}",digits
38,132,"/**
 * Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 *
 * Examples:
 *   is_nested('[[]]') ➞ true
 *   is_nested('[]]]]]]][[[[[]') ➞ false
 *   is_nested('[][]') ➞ false
 *   is_nested('[]') ➞ false
 *   is_nested('[[][]]') ➞ true
 *   is_nested('[[]][[') ➞ true
 */","/**
 * @param {string} string
 * @returns {boolean}
 */
function is_nested(string) {","const openingBracketIndex = [];
    const closingBracketIndex = [];
    for (let i = 0; i < string.length; i++) {
        if (string[i] === '[') {
            openingBracketIndex.push(i);
        } else {
            closingBracketIndex.push(i);
        }
    }
    closingBracketIndex.reverse();
    let cnt = 0;
    let j = 0;
    const l = closingBracketIndex.length;
    for (const idx of openingBracketIndex) {
        if (j < l && idx < closingBracketIndex[j]) {
            cnt++;
            j++;
        }
    }
    return cnt >= 2;
}",'assert'
39,133,"/**
 * You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int (Ceiling) first.
 * Examples:
 * For lst = [1,2,3] the output should be 14
 * For lst = [1,4,9] the output should be 98
 * For lst = [1,3,5,7] the output should be 84
 * For lst = [1.4,4.2,0] the output should be 29
 * For lst = [-2.4,1,1] the output should be 6
 *
 * @param {number[]} lst - array of numbers
 * @returns {number} sum of squares of the ceiling of each element
 */
function sumSquares(lst) {","let squared = 0;
    for (const i of lst) {
        squared += Math.ceil(i) ** 2;
    }
    return squared;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1,2,3]), 14, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([1.0,2,3]), 14, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([1,3,5,7]), 84, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([1.4,4.2,0]), 29, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([-2.4,1,1]), 6, ""This prints if this assert fails 1 (good for debugging!)"");

    assert.strictEqual(candidate([100,1,15,2]), 10230, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([10000,10000]), 200000000, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([-1.4,4.6,6.3]), 75, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([-1.4,17.9,18.9,19.9]), 1086, ""This prints if this assert fails 1 (good for debugging!)"");

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([0]), 0, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate([-1]), 1, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate([-1,1,0]), 2, ""This prints if this assert fails 2 (also good for debugging!)"");
}",sumSquares
40,134,"/**
 * Create a function that returns true if the last character
 * of a given string is an alphabetical character and is not
 * a part of a word, and false otherwise.
 * Note: ""word"" is a group of characters separated by space.
 *
 * Examples:
 *   checkIfLastCharIsALetter(""apple pie""); // false
 *   checkIfLastCharIsALetter(""apple pi e""); // true
 *   checkIfLastCharIsALetter(""apple pi e ""); // false
 *   checkIfLastCharIsALetter(""""); // false
 */
function checkIfLastCharIsALetter(txt) {","const parts = txt.split(' ');
    const last = parts[parts.length - 1];
    return last.length === 1 && (last.toLowerCase().charCodeAt(0) >= 97 && last.toLowerCase().charCodeAt(0) <= 122);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""apple""), false);
    assert.strictEqual(candidate(""apple pi e""), true);
    assert.strictEqual(candidate(""eeeee""), false);
    assert.strictEqual(candidate(""A""), true);
    assert.strictEqual(candidate(""Pumpkin pie ""), false);
    assert.strictEqual(candidate(""Pumpkin pie 1""), false);
    assert.strictEqual(candidate(""""), false);
    assert.strictEqual(candidate(""eeeee e ""), false);
    assert.strictEqual(candidate(""apple pie""), false);
    assert.strictEqual(candidate(""apple pi e ""), false);
}",checkIfLastCharIsALetter
41,135,"/**
 * Create a function which returns the largest index of an element which
 * is not greater than or equal to the element immediately preceding it. If
 * no such element exists then return -1. The given array will not contain
 * duplicate values.
 *
 * Examples:
 * can_arrange([1,2,4,3,5]) = 3
 * can_arrange([1,2,3]) = -1
 *
 * @param {number[]} arr
 * @returns {number}
 */
function can_arrange(arr) {","let ind = -1;
    let i = 1;
    while (i < arr.length) {
        if (arr[i] < arr[i - 1]) {
            ind = i;
        }
        i += 1;
    }
    return ind;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([1,2,4,3,5]), 3);
    assert.strictEqual(candidate([1,2,4,5]), -1);
    assert.strictEqual(candidate([1,4,2,5,6,7,8,9,10]), 2);
    assert.strictEqual(candidate([4,8,5,7,3]), 4);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([]), -1);
}",can_arrange
42,136,"/**
 * Create a function that returns an array [a, b], where 'a' is
 * the largest of negative integers, and 'b' is the smallest
 * of positive integers in an array.
 * If there is no negative or positive integers, return them as null.
 *
 * Examples:
 * largestSmallestIntegers([2, 4, 1, 3, 5, 7]) // [null, 1]
 * largestSmallestIntegers([]) // [null, null]
 * largestSmallestIntegers([0]) // [null, null]
 */
function largestSmallestIntegers(lst) {","const negatives = lst.filter(x => x < 0);
    const positives = lst.filter(x => x > 0);
    const a = negatives.length ? Math.max(...negatives) : null;
    const b = positives.length ? Math.min(...positives) : null;
    return [a, b];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([2, 4, 1, 3, 5, 7]), [null, 1]);
    assert.deepStrictEqual(candidate([2, 4, 1, 3, 5, 7, 0]), [null, 1]);
    assert.deepStrictEqual(candidate([1, 3, 2, 4, 5, 6, -2]), [-2, 1]);
    assert.deepStrictEqual(candidate([4, 5, 3, 6, 2, 7, -7]), [-7, 2]);
    assert.deepStrictEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]), [-9, 2]);
    assert.deepStrictEqual(candidate([]), [null, null]);
    assert.deepStrictEqual(candidate([0]), [null, null]);
    assert.deepStrictEqual(candidate([-1, -3, -5, -6]), [-1, null]);
    assert.deepStrictEqual(candidate([-1, -3, -5, -6, 0]), [-1, null]);
    assert.deepStrictEqual(candidate([-6, -4, -4, -3, 1]), [-3, 1]);
    assert.deepStrictEqual(candidate([-6, -4, -4, -3, -100, 1]), [-3, 1]);
    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",largestSmallestIntegers
43,137,"/**
 * Create a function that takes integers, floats, or strings representing
 * real numbers, and returns the larger variable in its given variable type.
 * Return null if the values are equal.
 * Note: If a real number is represented as a string, the floating point might be . or ,
 *
 * compare_one(1, 2.5) ➞ 2.5
 * compare_one(1, ""2,3"") ➞ ""2,3""
 * compare_one(""5,1"", ""6"") ➞ ""6""
 * compare_one(""1"", 1) ➞ null
 */
function compare_one(a, b) {","let tempA = a;
    let tempB = b;
    if (typeof tempA === ""string"") {
        tempA = tempA.replace("","", ""."");
    }
    if (typeof tempB === ""string"") {
        tempB = tempB.replace("","", ""."");
    }
    const numA = parseFloat(tempA);
    const numB = parseFloat(tempB);
    if (numA === numB) {
        return null;
    }
    return numA > numB ? a : b;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    const assert = require(""assert"");
    assert.strictEqual(candidate(1, 2), 2);
    assert.strictEqual(candidate(1, 2.5), 2.5);
    assert.strictEqual(candidate(2, 3), 3);
    assert.strictEqual(candidate(5, 6), 6);
    assert.strictEqual(candidate(1, ""2,3""), ""2,3"");
    assert.strictEqual(candidate(""5,1"", ""6""), ""6"");
    assert.strictEqual(candidate(""1"", ""2""), ""2"");
    assert.strictEqual(candidate(""1"", 1), null);
    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",compare_one
44,138,"/**
 * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * is_equal_to_sum_even(4) == false
 * is_equal_to_sum_even(6) == false
 * is_equal_to_sum_even(8) == true
 */
function is_equal_to_sum_even(n) {","return n % 2 === 0 && n >= 8;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(4), false);
    assert.strictEqual(candidate(6), false);
    assert.strictEqual(candidate(8), true);
    assert.strictEqual(candidate(10), true);
    assert.strictEqual(candidate(11), false);
    assert.strictEqual(candidate(12), true);
    assert.strictEqual(candidate(13), false);
    assert.strictEqual(candidate(16), true);
}",is_equal_to_sum_even
45,139,"/**
 * The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 *
 * For example:
 * >>> special_factorial(4)
 * 288
 *
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
 */
 
function special_factorial(n) {","let fact_i = 1;
    let special_fact = 1;
    for (let i = 1; i <= n; i++) {
        fact_i *= i;
        special_fact *= fact_i;
    }
    return special_fact;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(4), 288);
    assert.strictEqual(candidate(5), 34560);
    assert.strictEqual(candidate(7), 125411328000);
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(1), 1);
}",special_factorial
47,140,"/**
 * Given a string text, replace all spaces in it with underscores,
 * and if a string has more than 2 consecutive spaces,
 * then replace all consecutive spaces with -
 *
 * fixSpaces(""Example"") == ""Example""
 * fixSpaces(""Example 1"") == ""Example_1""
 * fixSpaces("" Example 2"") == ""_Example_2""
 * fixSpaces("" Example   3"") == ""_Example-3""
 *
 * @param {string} text
 * @returns {string}
 */
function fixSpaces(text) {","let newText = """";
    let i = 0;
    let start = 0, end = 0;
    while (i < text.length) {
        if (text[i] === "" "") {
            end += 1;
        } else {
            if (end - start > 2) {
                newText += ""-"" + text[i];
            } else if (end - start > 0) {
                newText += ""_"".repeat(end - start) + text[i];
            } else {
                newText += text[i];
            }
            start = i + 1;
            end = i + 1;
        }
        i++;
    }
    if (end - start > 2) {
        newText += ""-"";
    } else if (end - start > 0) {
        newText += ""_"";
    }
    return newText;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""Example""), ""Example"", ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(""Mudasir Hanif ""), ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)"");
    assert.strictEqual(candidate(""Yellow Yellow  Dirty  Fellow""), ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)"");
    assert.strictEqual(candidate(""Exa   mple""), ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)"");
    assert.strictEqual(candidate(""   Exa 1 2 2 mple""), ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)"");
}",fixSpaces
48,141,"/**
 * Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from
 *   the Latin alphabet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 *
 * @param {string} file_name
 * @returns {'Yes'|'No'}
 */
function file_name_check(file_name) {","const suf = ['txt', 'exe', 'dll'];
    const parts = file_name.split('.');
    if (parts.length !== 2) {
        return 'No';
    }
    const [name, ext] = parts;
    if (!suf.includes(ext)) {
        return 'No';
    }
    if (name.length === 0) {
        return 'No';
    }
    if (!/^[A-Za-z]/.test(name)) {
        return 'No';
    }
    const digitCount = (name.match(/\d/g) || []).length;
    if (digitCount > 3) {
        return 'No';
    }
    return 'Yes';
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""example.txt""), 'Yes');
    assert.strictEqual(candidate(""1example.dll""), 'No');
    assert.strictEqual(candidate('s1sdf3.asd'), 'No');
    assert.strictEqual(candidate('K.dll'), 'Yes');
    assert.strictEqual(candidate('MY16FILE3.exe'), 'Yes');
    assert.strictEqual(candidate('His12FILE94.exe'), 'No');
    assert.strictEqual(candidate('_Y.txt'), 'No');
    assert.strictEqual(candidate('?aREYA.exe'), 'No');
    assert.strictEqual(candidate('/this_is_valid.dll'), 'No');
    assert.strictEqual(candidate('this_is_valid.wow'), 'No');
    assert.strictEqual(candidate('this_is_valid.txt'), 'Yes');
    assert.strictEqual(candidate('this_is_valid.txtexe'), 'No');
    assert.strictEqual(candidate('#this2_i4s_5valid.ten'), 'No');
    assert.strictEqual(candidate('@this1_is6_valid.exe'), 'No');
    assert.strictEqual(candidate('this_is_12valid.6exe4.txt'), 'No');
    assert.strictEqual(candidate('all.exe.txt'), 'No');
    assert.strictEqual(candidate('I563_No.exe'), 'Yes');
    assert.strictEqual(candidate('Is3youfault.txt'), 'Yes');
    assert.strictEqual(candidate('no_one#knows.dll'), 'Yes');
    assert.strictEqual(candidate('1I563_Yes3.exe'), 'No');
    assert.strictEqual(candidate('I563_Yes3.txtt'), 'No');
    assert.strictEqual(candidate('final..txt'), 'No');
    assert.strictEqual(candidate('final132'), 'No');
    assert.strictEqual(candidate('_f4indsartal132.'), 'No');
    assert.strictEqual(candidate('.txt'), 'No');
    assert.strictEqual(candidate('s.'), 'No');
}",file_name_check
49,142,"/**
 * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a 
 * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
 * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
 *
 * Examples:
 * For lst = [1,2,3] the output should be 6
 * For lst = []  the output should be 0
 * For lst = [-1,-5,2,-1,-5]  the output should be -126
 *
 * @param {number[]} lst
 * @returns {number}
 */
function sumSquares(lst) {","const result = [];
    for (let i = 0; i < lst.length; i++) {
        if (i % 3 === 0) {
            result.push(lst[i] ** 2);
        } else if (i % 4 === 0 && i % 3 !== 0) {
            result.push(lst[i] ** 3);
        } else {
            result.push(lst[i]);
        }
    }
    return result.reduce((acc, val) => acc + val, 0);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([1,2,3]), 6);
    assert.strictEqual(candidate([1,4,9]), 14);
    assert.strictEqual(candidate([]), 0);
    assert.strictEqual(candidate([1,1,1,1,1,1,1,1,1]), 9);
    assert.strictEqual(candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]), -3);
    assert.strictEqual(candidate([0]), 0);
    assert.strictEqual(candidate([-1,-5,2,-1,-5]), -126);
    assert.strictEqual(candidate([-56,-99,1,0,-2]), 3030);
    assert.strictEqual(candidate([-1,0,0,0,0,0,0,0,-1]), 0);
    assert.strictEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert.strictEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}",sumSquares
50,143,"/**
 * You are given a string representing a sentence,
 * the sentence contains some words separated by a space,
 * and you have to return a string that contains the words from the original sentence,
 * whose lengths are prime numbers,
 * the order of the words in the new string should be the same as the original one.
 *
 * Example 1:
 *     Input: sentence = ""This is a test""
 *     Output: ""is""
 *
 * Example 2:
 *     Input: sentence = ""lets go for swimming""
 *     Output: ""go for""
 *
 * Constraints:
 *     * 1 <= len(sentence) <= 100
 *     * sentence contains only letters
 */

function wordsInSentence(sentence) {","const words = sentence.split(' ');
    const result = [];

    /**
     * Check if a number is prime.
     * @param {number} n
     * @returns {boolean}
     */
    const isPrime = (n) => {
        if (n <= 1) return false;
        if (n === 2) return true;
        for (let i = 2; i < n; i++) {
            if (n % i === 0) return false;
        }
        return true;
    };

    for (const word of words) {
        if (isPrime(word.length)) {
            result.push(word);
        }
    }

    return result.join(' ');
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""This is a test""), ""is"");
    assert.strictEqual(candidate(""lets go for swimming""), ""go for"");
    assert.strictEqual(candidate(""there is no place available here""), ""there is no place"");
    assert.strictEqual(candidate(""Hi I am Hussein""), ""Hi am Hussein"");
    assert.strictEqual(candidate(""go for it""), ""go for it"");

    // Edge cases
    assert.strictEqual(candidate(""here""), """");
    assert.strictEqual(candidate(""here is""), ""is"");
}",wordsInSentence
51,144,"/**
 * Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n are string representations of a fraction, and have the following format:
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 *
 * You can assume that x and n are valid fractions, and do not have zero as denominator.
 *
 * Examples:
 * simplify(""1/5"", ""5/1"") = true
 * simplify(""1/6"", ""2/1"") = false
 * simplify(""7/10"", ""10/2"") = false
 *
 * @param {string} x - Fraction in the format ""numerator/denominator""
 * @param {string} n - Fraction in the format ""numerator/denominator""
 * @returns {boolean} - True if x * n is a whole number, false otherwise
 */
function simplify(x, n) {","const [a, b] = x.split(""/"");
    const [c, d] = n.split(""/"");
    const numerator = parseInt(a, 10) * parseInt(c, 10);
    const denom = parseInt(b, 10) * parseInt(d, 10);
    return numerator % denom === 0;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""1/5"", ""5/1""), true, 'test1');
    assert.strictEqual(candidate(""1/6"", ""2/1""), false, 'test2');
    assert.strictEqual(candidate(""5/1"", ""3/1""), true, 'test3');
    assert.strictEqual(candidate(""7/10"", ""10/2""), false, 'test4');
    assert.strictEqual(candidate(""2/10"", ""50/10""), true, 'test5');
    assert.strictEqual(candidate(""7/2"", ""4/2""), true, 'test6');
    assert.strictEqual(candidate(""11/6"", ""6/1""), true, 'test7');
    assert.strictEqual(candidate(""2/3"", ""5/2""), false, 'test8');
    assert.strictEqual(candidate(""5/2"", ""3/5""), false, 'test9');
    assert.strictEqual(candidate(""2/4"", ""8/4""), true, 'test10');
    assert.strictEqual(candidate(""2/4"", ""4/2""), true, 'test11');
    assert.strictEqual(candidate(""1/5"", ""5/1""), true, 'test12');
    assert.strictEqual(candidate(""1/5"", ""1/5""), false, 'test13');
}",simplify
52,145,"/**
 * Write a function which sorts the given array of integers
 * in ascending order according to the sum of their digits.
 * Note: if there are several items with similar sum of their digits,
 * order them based on their index in original array.
 *
 * @param {number[]} nums
 * @returns {number[]}
 *
 * @example
 * order_by_points([1, 11, -1, -11, -12]); // [-1, -11, 1, -12, 11]
 */
function order_by_points(nums) {","function digits_sum(n) {
        let neg = 1;
        if (n < 0) {
            n = -n;
            neg = -1;
        }
        const digits = String(n).split('').map(d => parseInt(d, 10));
        if (digits.length > 0) {
            digits[0] *= neg;
        }
        return digits.reduce((acc, cur) => acc + cur, 0);
    }
    return nums
        .map((n, i) => ({ value: n, index: i, points: digits_sum(n) }))
        .sort((a, b) => a.points - b.points || a.index - b.index)
        .map(item => item.value);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([1, 11, -1, -11, -12]), [-1, -11, 1, -12, 11]);
    assert.deepStrictEqual(
        candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]),
        [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    );
    assert.deepStrictEqual(candidate([]), []);
    assert.deepStrictEqual(
        candidate([1, -11, -32, 43, 54, -98, 2, -3]),
        [-3, -32, -98, -11, 1, 2, 43, 54]
    );
    assert.deepStrictEqual(
        candidate([1,2,3,4,5,6,7,8,9,10,11]),
        [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    );
    assert.deepStrictEqual(candidate([0,6,6,-76,-21,23,4]), [-76, -21, 0, 4, 23, 6, 6]);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",order_by_points
53,146,"/**
 * Write a function that takes an array of numbers as input and returns 
 * the number of elements in the array that are greater than 10 and both 
 * first and last digits of a number are odd (1, 3, 5, 7, 9).
 * For example:
 * specialFilter([15, -73, 14, -15]) => 1 
 * specialFilter([33, -2, -3, 45, 21, 109]) => 2
 */
/**
 * @param {number[]} nums
 * @returns {number}
 */
function specialFilter(nums) {","let count = 0;
    const oddDigits = new Set([1, 3, 5, 7, 9]);
    for (const num of nums) {
        if (num > 10) {
            const str = String(num);
            const first = parseInt(str[0], 10);
            const last = parseInt(str[str.length - 1], 10);
            if (oddDigits.has(first) && oddDigits.has(last)) {
                count++;
            }
        }
    }
    return count;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate([5, -2, 1, -5]), 0);
    assert.strictEqual(candidate([15, -73, 14, -15]), 1);
    assert.strictEqual(candidate([33, -2, -3, 45, 21, 109]), 2);
    assert.strictEqual(candidate([43, -12, 93, 125, 121, 109]), 4);
    assert.strictEqual(candidate([71, -2, -33, 75, 21, 19]), 3);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate([1]), 0);
    assert.strictEqual(candidate([]), 0);
}",specialFilter
54,147,"/**
 * You are given a positive integer n. You have to create an integer array a of length n.
 * For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
 * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,
 * and a[i] + a[j] + a[k] is a multiple of 3.
 *
 * Example :
 *   Input: n = 5
 *   Output: 1
 *   Explanation:
 *     a = [1, 3, 7, 13, 21]
 *     The only valid triple is (1, 7, 13).
 */
function get_max_triples(n) {","const A = [];
    for (let i = 1; i <= n; i++) {
        A.push(i * i - i + 1);
    }
    let count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            for (let k = j + 1; k < n; k++) {
                if ((A[i] + A[j] + A[k]) % 3 === 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(5), 1);
    assert.strictEqual(candidate(6), 4);
    assert.strictEqual(candidate(10), 36);
    assert.strictEqual(candidate(100), 53361);
}",get_max_triples
55,148,"/**
 * There are eight planets in our solar system: the closest to the Sun is Mercury,
 * the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune.
 * Write a function that takes two planet names as strings planet1 and planet2.
 * The function should return an array containing all planets whose orbits are
 * located between the orbit of planet1 and the orbit of planet2, sorted by
 * proximity to the sun.
 * The function should return an empty array if planet1 or planet2
 * are not correct planet names or if they are the same.
 *
 * Examples:
 * bf(""Jupiter"", ""Neptune"") ==> [""Saturn"", ""Uranus""]
 * bf(""Earth"", ""Mercury"") ==> [""Venus""]
 * bf(""Mercury"", ""Uranus"") ==> [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
 *
 * @param {string} planet1
 * @param {string} planet2
 * @returns {string[]}
 */
function bf(planet1, planet2) {","const planetNames = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""];
    if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {
        return [];
    }
    const index1 = planetNames.indexOf(planet1);
    const index2 = planetNames.indexOf(planet2);
    if (index1 < index2) {
        return planetNames.slice(index1 + 1, index2);
    } else {
        return planetNames.slice(index2 + 1, index1);
    }
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(""Jupiter"", ""Neptune""), [""Saturn"", ""Uranus""], ""First test error: "" + JSON.stringify(candidate(""Jupiter"", ""Neptune"")));
    assert.deepStrictEqual(candidate(""Earth"", ""Mercury""), [""Venus""], ""Second test error: "" + JSON.stringify(candidate(""Earth"", ""Mercury"")));
    assert.deepStrictEqual(candidate(""Mercury"", ""Uranus""), [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], ""Third test error: "" + JSON.stringify(candidate(""Mercury"", ""Uranus"")));
    assert.deepStrictEqual(candidate(""Neptune"", ""Venus""), [""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], ""Fourth test error: "" + JSON.stringify(candidate(""Neptune"", ""Venus"")));

    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate(""Earth"", ""Earth""), [], ""Edge case Earth-Earth failed"");
    assert.deepStrictEqual(candidate(""Mars"", ""Earth""), [], ""Edge case Mars-Earth failed"");
    assert.deepStrictEqual(candidate(""Jupiter"", ""Makemake""), [], ""Edge case invalid planet failed"");
}",bf
56,149,"/**
 * Write a function that accepts an array of strings as a parameter,
 * deletes the strings that have odd lengths from it,
 * and returns the resulting array with sorted order.
 * The array may contain duplicates.
 * The order should be ascending by length of each word.
 * If two words have the same length, sort alphabetically.
 * The function returns an array of strings in sorted order.
 *
 * For example:
 * sorted_list_sum([""aa"", ""a"", ""aaa""]) => [""aa""]
 * sorted_list_sum([""ab"", ""a"", ""aaa"", ""cd""]) => [""ab"", ""cd""]
 */
function sorted_list_sum(lst) {","lst.sort();
    const new_lst = [];
    for (const i of lst) {
        if (i.length % 2 === 0) {
            new_lst.push(i);
        }
    }
    return new_lst.sort((a, b) => {
        return a.length - b.length;
    });
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate([""aa"", ""a"", ""aaa""]), [""aa""]);
    assert.deepStrictEqual(candidate([""school"", ""AI"", ""asdf"", ""b""]), [""AI"", ""asdf"", ""school""]);
    assert.deepStrictEqual(candidate([""d"", ""b"", ""c"", ""a""]), []);
    assert.deepStrictEqual(candidate([""d"", ""dcba"", ""abcd"", ""a""]), [""abcd"", ""dcba""]);

    // Check some edge cases that are easy to work out by hand.
    assert.deepStrictEqual(candidate([""AI"", ""ai"", ""au""]), [""AI"", ""ai"", ""au""]);
    assert.deepStrictEqual(candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]), []);
    assert.deepStrictEqual(candidate([""aaaa"", ""bbbb"", ""dd"", ""cc""]), [""cc"", ""dd"", ""aaaa"", ""bbbb""]);
}",sorted_list_sum
58,150,"/**
 * A simple program which should return the value of x if n is
 * a prime number and should return the value of y otherwise.
 *
 * Examples:
 * for x_or_y(7, 34, 12) == 34
 * for x_or_y(15, 8, 5) == 5
 *
 * @param {number} n
 * @param {*} x
 * @param {*} y
 * @returns {*}
 */
function x_or_y(n, x, y) {","if (n === 1) {
    return y;
  }
  for (let i = 2; i < n; i++) {
    if (n % i === 0) {
      return y;
    }
  }
  return x;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate(7, 34, 12), 34);
  assert.strictEqual(candidate(15, 8, 5), 5);
  assert.strictEqual(candidate(3, 33, 5212), 33);
  assert.strictEqual(candidate(1259, 3, 52), 3);
  assert.strictEqual(candidate(7919, -1, 12), -1);
  assert.strictEqual(candidate(3609, 1245, 583), 583);
  assert.strictEqual(candidate(91, 56, 129), 129);
  assert.strictEqual(candidate(6, 34, 1234), 1234);

  // Check some edge cases that are easy to work out by hand.
  assert.strictEqual(candidate(1, 2, 0), 0);
  assert.strictEqual(candidate(2, 2, 0), 2);
}",x_or_y
59,151,"/**
 * Given a list of numbers, return the sum of squares of the numbers
 * in the list that are odd. Ignore numbers that are negative or not integers.
 *
 * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
 * double_the_difference([-1, -2, 0]) == 0
 * double_the_difference([9, -2]) == 81
 * double_the_difference([0]) == 0
 *
 * If the input list is empty, return 0.
 *
 * @param {number[]} lst
 * @returns {number}
 */
function double_the_difference(lst) {","return lst
        .filter(i => Number.isInteger(i) && i > 0 && i % 2 !== 0)
        .reduce((sum, i) => sum + i * i, 0);
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate([]), 0, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate([5, 4]), 25, ""This prints if this assert fails 2 (good for debugging!)"");
    assert.strictEqual(candidate([0.1, 0.2, 0.3]), 0, ""This prints if this assert fails 3 (good for debugging!)"");
    assert.strictEqual(candidate([-10, -20, -30]), 0, ""This prints if this assert fails 4 (good for debugging!)"");
    assert.strictEqual(candidate([-1, -2, 8]), 0, ""This prints if this assert fails 5 (also good for debugging!)"");
    assert.strictEqual(candidate([0.2, 3, 5]), 34, ""This prints if this assert fails 6 (also good for debugging!)"");
    const lst = [];
    for (let i = -99; i < 100; i += 2) {
        lst.push(i);
    }
    const odd_sum = lst
        .filter(i => i % 2 !== 0 && i > 0)
        .reduce((s, i) => s + i * i, 0);
    assert.strictEqual(candidate(lst), odd_sum, ""This prints if this assert fails 7 (good for debugging!)"");
}",double_the_difference
60,152,"/**
 * I think we all remember that feeling when the result of some long-awaited
 * event is finally known. The feelings and thoughts you have at that moment are
 * definitely worth noting down and comparing.
 * Your task is to determine if a person correctly guessed the results of a number of matches.
 * You are given two arrays of scores and guesses of equal length, where each index shows a match.
 * Return an array of the same length denoting how far off each guess was. If they have guessed correctly,
 * the value is 0, and if not, the value is the absolute difference between the guess and the score.
 *
 * example:
 * compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]
 * compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]
 *
 * @param {number[]} game - actual scores
 * @param {number[]} guess - guessed scores
 * @returns {number[]} differences between game and guess
 */
function compare(game, guess) {","return game.map((score, index) => Math.abs(score - guess[index]));
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.deepStrictEqual(candidate([1,2,3,4,5,1],[1,2,3,4,2,-2]), [0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([0,0,0,0,0,0],[0,0,0,0,0,0]), [0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([1,2,3],[-1,-2,-3]), [2,4,6], ""This prints if this assert fails 1 (good for debugging!)"");
    assert.deepStrictEqual(candidate([1,2,3,5],[-1,2,3,4]), [2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)"");
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(true, true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",compare
61,153,"/**
 * You will be given the name of a class (a string) and a list of extensions.
 * The extensions are to be used to load additional classes to the class. The
 * strength of the extension is as follows: Let CAP be the number of the uppercase
 * letters in the extension's name, and let SM be the number of lowercase letters 
 * in the extension's name, the strength is given by the fraction CAP - SM. 
 * You should find the strongest extension and return a string in this 
 * format: ClassName.StrongestExtensionName.
 * If there are two or more extensions with the same strength, you should
 * choose the one that comes first in the list.
 * For example, if you are given ""Slices"" as the class and a list of the
 * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
 * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
 * (its strength is -1).
 * Example:
 * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'
 */","function Strongest_Extension(className, extensions) {
    let strong = extensions[0];
    const countUpper = s => (s.match(/[A-Z]/g) || []).length;
    const countLower = s => (s.match(/[a-z]/g) || []).length;
    let myVal = countUpper(strong) - countLower(strong);
    for (const s of extensions) {
        const val = countUpper(s) - countLower(s);
        if (val > myVal) {
            strong = s;
            myVal = val;
        }
    }
    return `${className}.${strong}`;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']), 'Watashi.eIGHt8OKe');
    assert.strictEqual(candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']), 'Boku123.YEs.WeCaNe');
    assert.strictEqual(candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']), '__YESIMHERE.NuLl__');
    assert.strictEqual(candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']), 'K.TAR');
    assert.strictEqual(candidate('__HAHA', ['Tab', '123', '781345', '-_-']), '__HAHA.123');
    assert.strictEqual(candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']), 'YameRore.okIWILL123');
    assert.strictEqual(candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']), 'finNNalLLly.WoW');

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate('_', ['Bb', '91245']), '_.Bb');
    assert.strictEqual(candidate('Sp', ['671235', 'Bb']), 'Sp.671235');
}",Strongest_Extension
62,154,"/**
 * You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word
 * cycpattern_check(""abcd"",""abd"") => False
 * cycpattern_check(""hello"",""ell"") => True
 * cycpattern_check(""whassup"",""psus"") => False
 * cycpattern_check(""abab"",""baa"") => True
 * cycpattern_check(""efef"",""eeff"") => False
 * cycpattern_check(""himenss"",""simen"") => True
 */
function cycpattern_check(a, b) {","const l = b.length;
    const pat = b + b;
    for (let i = 0; i <= a.length - l; i++) {
        for (let j = 0; j <= l; j++) {
            if (a.substr(i, l) === pat.substr(j, l)) {
                return true;
            }
        }
    }
    return false;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(""xyzw"",""xyw""), false, ""test #0"");
    assert.strictEqual(candidate(""yello"",""ell""), true, ""test #1"");
    assert.strictEqual(candidate(""whattup"",""ptut""), false, ""test #2"");
    assert.strictEqual(candidate(""efef"",""fee""), true, ""test #3"");
    assert.strictEqual(candidate(""abab"",""aabb""), false, ""test #4"");
    assert.strictEqual(candidate(""winemtt"",""tinem""), true, ""test #5"");
}",cycpattern_check
63,155,"/**
 * Given an integer, return an array that has the number of even and odd digits respectively.
 *
 * Example:
 *   evenOddCount(-12) ==> [1, 1]
 *   evenOddCount(123) ==> [1, 2]
 */
function evenOddCount(num) {","let evenCount = 0;
    let oddCount = 0;
    for (const digit of Math.abs(num).toString()) {
        if (parseInt(digit, 10) % 2 === 0) {
            evenCount += 1;
        } else {
            oddCount += 1;
        }
    }
    return [evenCount, oddCount];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(7), [0, 1]);
    assert.deepStrictEqual(candidate(-78), [1, 1]);
    assert.deepStrictEqual(candidate(3452), [2, 2]);
    assert.deepStrictEqual(candidate(346211), [3, 3]);
    assert.deepStrictEqual(candidate(-345821), [3, 3]);
    assert.deepStrictEqual(candidate(-2), [1, 0]);
    assert.deepStrictEqual(candidate(-45347), [2, 3]);
    assert.deepStrictEqual(candidate(0), [1, 0]);

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",evenOddCount
64,156,"/**
 * Given a positive integer, obtain its roman numeral equivalent as a string,
 * and return it in lowercase.
 * Restrictions: 1 <= num <= 1000
 *
 * Examples:
 * >>> int_to_mini_roman(19) == 'xix'
 * >>> int_to_mini_roman(152) == 'clii'
 * >>> int_to_mini_roman(426) == 'cdxxvi'
 */
function int_to_mini_roman(number) {","const num = [1, 4, 5, 9, 10, 40, 50, 90,
                 100, 400, 500, 900, 1000];
    const sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",
                 ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""];
    let i = 12;
    let res = '';
    while (number > 0) {
        const div = Math.floor(number / num[i]);
        number %= num[i];
        for (let count = 0; count < div; count++) {
            res += sym[i];
        }
        i -= 1;
    }
    return res.toLowerCase();
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(19), 'xix');
    assert.strictEqual(candidate(152), 'clii');
    assert.strictEqual(candidate(251), 'ccli');
    assert.strictEqual(candidate(426), 'cdxxvi');
    assert.strictEqual(candidate(500), 'd');
    assert.strictEqual(candidate(1), 'i');
    assert.strictEqual(candidate(4), 'iv');
    assert.strictEqual(candidate(43), 'xliii');
    assert.strictEqual(candidate(90), 'xc');
    assert.strictEqual(candidate(94), 'xciv');
    assert.strictEqual(candidate(532), 'dxxxii');
    assert.strictEqual(candidate(900), 'cm');
    assert.strictEqual(candidate(994), 'cmxciv');
    assert.strictEqual(candidate(1000), 'm');

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true);
}",int_to_mini_roman
65,157,"/**
 * Given the lengths of the three sides of a triangle. Return true if the three
 * sides form a right-angled triangle, false otherwise.
 * A right-angled triangle is a triangle in which one angle is right angle or 
 * 90 degree.
 * Example:
 * right_angle_triangle(3, 4, 5) === true
 * right_angle_triangle(1, 2, 3) === false
 */
function right_angle_triangle(a, b, c) {","return a * a === b * b + c * c ||
           b * b === a * a + c * c ||
           c * c === a * a + b * b;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(3, 4, 5), true, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.strictEqual(candidate(1, 2, 3), false);
    assert.strictEqual(candidate(10, 6, 8), true);
    assert.strictEqual(candidate(2, 2, 2), false);
    assert.strictEqual(candidate(7, 24, 25), true);
    assert.strictEqual(candidate(10, 5, 7), false);
    assert.strictEqual(candidate(5, 12, 13), true);
    assert.strictEqual(candidate(15, 8, 17), true);
    assert.strictEqual(candidate(48, 55, 73), true);

    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(1, 1, 1), false, ""This prints if this assert fails 2 (also good for debugging!)"");
    assert.strictEqual(candidate(2, 2, 10), false);
}",right_angle_triangle
66,158,"/**
 * Write a function that accepts a list of strings.
 * The list contains different words. Return the word with maximum number
 * of unique characters. If multiple strings have maximum number of unique
 * characters, return the one which comes first in lexicographical order.
 *
 * find_max([""name"", ""of"", ""string""]) == ""string""
 * find_max([""name"", ""enam"", ""game""]) == ""enam""
 * find_max([""aaaaaaa"", ""bb"" ,""cc""]) == ""aaaaaaa""
 */
function find_max(words) {","return words.slice().sort((a, b) => {
        const ua = new Set(a).size;
        const ub = new Set(b).size;
        if (ub - ua !== 0) return ub - ua;
        return a.localeCompare(b);
    })[0];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert(candidate([""name"", ""of"", ""string""]) === ""string"", ""t1"");
    assert(candidate([""name"", ""enam"", ""game""]) === ""enam"", ""t2"");
    assert(candidate([""aaaaaaa"", ""bb"", ""cc""]) === ""aaaaaaa"", ""t3"");
    assert(candidate([""abc"", ""cba""]) === ""abc"", ""t4"");
    assert(candidate([""play"", ""this"", ""game"", ""of"", ""footbott""]) === ""footbott"", ""t5"");
    assert(candidate([""we"", ""are"", ""gonna"", ""rock""]) === ""gonna"", ""t6"");
    assert(candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) === ""nation"", ""t7"");
    assert(candidate([""this"", ""is"", ""a"", ""prrk""]) === ""this"", ""t8"");

    // Check some edge cases that are easy to work out by hand.
    assert(candidate([""b""]) === ""b"", ""t9"");
    assert(candidate([""play"", ""play"", ""play""]) === ""play"", ""t10"");
}",find_max
67,159,"/**
 * You're a hungry rabbit, and you already have eaten a certain number of carrots,
 * but now you need to eat more carrots to complete the day's meals.
 * You should return an array of [ total number of eaten carrots after your meals,
 *                              the number of carrots left after your meals ].
 * If there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
 *
 * Example:
 * eat(5, 6, 10) -> [11, 4]
 * eat(4, 8, 9)  -> [12, 1]
 * eat(1, 10, 10)-> [11, 0]
 * eat(2, 11, 5) -> [7, 0]
 *
 * @param {number} number - the number of carrots that you have eaten.
 * @param {number} need - the number of carrots that you need to eat.
 * @param {number} remaining - the number of remaining carrots that exist in stock.
 * @returns {[number, number]} [ total eaten after meals, carrots left after meals ].
 */
function eat(number, need, remaining) {","if (need <= remaining) {
        return [number + need, remaining - need];
    } else {
        return [number + remaining, 0];
    }
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.ok(true, 'This prints if this assert fails 1 (good for debugging!)');
    assert.deepStrictEqual(candidate(5, 6, 10), [11, 4], 'Error');
    assert.deepStrictEqual(candidate(4, 8, 9), [12, 1], 'Error');
    assert.deepStrictEqual(candidate(1, 10, 10), [11, 0], 'Error');
    assert.deepStrictEqual(candidate(2, 11, 5), [7, 0], 'Error');

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, 'This prints if this assert fails 2 (also good for debugging!)');
    assert.deepStrictEqual(candidate(4, 5, 7), [9, 2], 'Error');
    assert.deepStrictEqual(candidate(4, 5, 1), [5, 0], 'Error');
}",eat
69,160,"/**
 * Given two lists operator, and operand. The first list has basic algebra operations,
 * and the second list is a list of integers. Use the two given lists to build the algebra
 * expression and return the evaluation of this expression.
 *
 * The basic algebra operations:
 *   Addition ( + )
 *   Subtraction ( - )
 *   Multiplication ( * )
 *   Floor division ( // )
 *   Exponentiation ( ** )
 *
 * Example:
 *   operator = ['+', '*', '-']
 *   operand  = [2, 3, 4, 5]
 *   result = 2 + 3 * 4 - 5 => 9
 *
 * Note:
 *   The length of operator list is equal to the length of operand list minus one.
 *   Operands are non-negative integers.
 *   Operator list has at least one operator, and operand list has at least two operands.
 *
 * @param {string[]} operator - array of operators
 * @param {number[]} operand - array of non-negative integers
 * @returns {number} evaluation of built expression
 */
function do_algebra(operator, operand) {","const ops = operator.slice();
    const vals = operand.slice();

    // handle exponentiation (right-associative)
    while (true) {
        const i = ops.lastIndexOf('**');
        if (i === -1) break;
        const res = vals[i] ** vals[i + 1];
        vals.splice(i, 2, res);
        ops.splice(i, 1);
    }

    // handle multiplication and floor division (left-associative)
    let idx;
    while ((idx = ops.findIndex(op => op === '*' || op === '//')) !== -1) {
        const op = ops[idx];
        const a = vals[idx], b = vals[idx + 1];
        const res = op === '*' ? a * b : Math.floor(a / b);
        vals.splice(idx, 2, res);
        ops.splice(idx, 1);
    }

    // handle addition and subtraction (left-associative)
    while ((idx = ops.findIndex(op => op === '+' || op === '-')) !== -1) {
        const op = ops[idx];
        const a = vals[idx], b = vals[idx + 1];
        const res = op === '+' ? a + b : a - b;
        vals.splice(idx, 2, res);
        ops.splice(idx, 1);
    }

    return vals[0];
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    assert.strictEqual(candidate(['**', '*', '+'], [2, 3, 4, 5]), 37);
    assert.strictEqual(candidate(['+', '*', '-'], [2, 3, 4, 5]), 9);
    assert.strictEqual(candidate(['//', '*'], [7, 3, 4]), 8, ""This prints if this assert fails 1 (good for debugging!)"");
    assert.ok(true, ""This prints if this assert fails 2 (also good for debugging!)"");
}",do_algebra
70,161,"/**
 * You are given a string s.
 * if s[i] is a letter, reverse its case from lower to upper or vise versa,
 * otherwise keep it as it is.
 * If the string contains no letters, reverse the string.
 * The function should return the resulted string.
 * Examples
 * solve(""1234"") = ""4321""
 * solve(""ab"") = ""AB""
 * solve(""#a@C"") = ""#A@c""
 * @param {string} s
 * @returns {string}
 */
function solve(s) {","let flg = 0;
    const newStr = s.split('');
    for (let idx = 0; idx < s.length; idx++) {
        const ch = s[idx];
        if (/[a-zA-Z]/.test(ch)) {
            newStr[idx] = ch === ch.toLowerCase() ? ch.toUpperCase() : ch.toLowerCase();
            flg = 1;
        }
    }
    const result = newStr.join('');
    if (flg === 0) {
        return result.split('').reverse().join('');
    }
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.strictEqual(candidate(""AsDf""), ""aSdF"");
    assert.strictEqual(candidate(""1234""), ""4321"");
    assert.strictEqual(candidate(""ab""), ""AB"");
    assert.strictEqual(candidate(""#a@C""), ""#A@c"");
    assert.strictEqual(candidate(""#AsdfW^45""), ""#aSDFw^45"");
    assert.strictEqual(candidate(""#6@2""), ""2@6#"");
    // Check some edge cases that are easy to work out by hand.
    assert.strictEqual(candidate(""#$a^D""), ""#$A^d"");
    assert.strictEqual(candidate(""#ccc""), ""#CCC"");
}",solve
71,162,"const crypto = require('crypto');
/**
 * Given a string 'text', return its md5 hash equivalent string.
 * If 'text' is an empty string, return null.
 *
 * @param {string} text
 * @returns {string|null}
 */
function stringToMd5(text) {","if (text === '') {
    return null;
  }
  return crypto.createHash('md5').update(text, 'ascii').digest('hex');
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
  // Check some simple cases
  assert.strictEqual(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62');
  assert.strictEqual(candidate(''), null);
  assert.strictEqual(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888');
  assert.strictEqual(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99');
  // Check some edge cases that are easy to work out by hand.
  assert.ok(true);
}",stringToMd5
72,163,"/**
 * Given two positive integers a and b, return the even digits between a
 * and b, in ascending order.
 *
 * For example:
 * generateIntegers(2, 8) => [2, 4, 6, 8]
 * generateIntegers(8, 2) => [2, 4, 6, 8]
 * generateIntegers(10, 14) => []
 */
function generateIntegers(a, b) {","const lower = Math.max(2, Math.min(a, b));
    const upper = Math.min(8, Math.max(a, b));
    const result = [];
    for (let i = lower; i <= upper; i++) {
        if (i % 2 === 0) {
            result.push(i);
        }
    }
    return result;
}","const METADATA = {
    author: 'jt',
    dataset: 'test'
};

const assert = require('assert');

function check(candidate) {
    // Check some simple cases
    assert.deepStrictEqual(candidate(2, 10), [2, 4, 6, 8], 'Test 1');
    assert.deepStrictEqual(candidate(10, 2), [2, 4, 6, 8], 'Test 2');
    assert.deepStrictEqual(candidate(132, 2), [2, 4, 6, 8], 'Test 3');
    assert.deepStrictEqual(candidate(17, 89), [], 'Test 4');

    // Check some edge cases that are easy to work out by hand.
    assert.ok(true, 'This prints if this assert fails 2 (also good for debugging!)');
}",generateIntegers
